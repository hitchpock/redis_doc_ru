- [Введение](#введение)
- [Начало работы](#начало-работы)
  - [Использование CLI](#использование-cli)
  - [Безопасность](#безопасность)
  - [Персистентность](#персистентность)
- [Типы данных](#типы-данных)
  - [Руководство](#руководство)
    - [Ключи](#ключи)
    - [Строки](#строки)
    - [Изменение и запрос пространства ключей](#изменение-и-запрос-пространства-ключей)
    - [Истечение срока действия ключа](#истечение-срока-действия-ключа)
    - [Списки](#списки)
      - [Первые шаги со списками Redis](#первые-шаги-со-списками-redis)
      - [Распространенные варианты использования списков](#распространенные-варианты-использования-списков)
      - [Ограниченные списки](#ограниченные-списки)
- [Использование Redis](#использование-redis)
  - [Redis CLI](#redis-cli)
    - [Использование командной строки](#использование-командной-строки)
    - [Хост, порт, пароль и база данных](#хост-порт-пароль-и-база-данных)
    - [SSL/TLS](#ssltls)
    - [Получение входных данных от других программ](#получение-входных-данных-от-других-программ)
    - [Постоянное выполнение команд](#постоянное-выполнение-команд)
    - [CSV вывод](#csv-вывод)
    - [Обработка соединений и реконектов](#обработка-соединений-и-реконектов)
    - [Выполнение одной и той же команды N раз](#выполнение-одной-и-той-же-команды-n-раз)
    - [Непрерывный режим статистики](#непрерывный-режим-статистики)
    - [Сканирование на наличие больших ключей](#сканирование-на-наличие-больших-ключей)
- [Управление Redis](#управление-redis)
  - [Администрирование Redis](#администрирование-redis)
    - [Память](#память)
    - [Репликация](#репликация)
    - [Обновление или перезапуск экземпляра Redis без простоев](#обновление-или-перезапуск-экземпляра-redis-без-простоев)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


# Введение

Redis - это хранилище структур данных в памяти с открытым исходным кодом (лицензия BSD), используемое в качестве базы данных, кэша, брокера сообщений и механизма потоковой передачи. Redis предоставляет такие структуры данных как строки, хэши, списки, наборы, растровые изображения, гиперлоги, геопространственные индексы и потоки. Redis имеет встроенную репликацию, сценарии Lua, удаление по LRU, транзакции и различные уровни сохраняемости на диске, а также обеспечивает высокую доступность с помощью Redis Sentinel и автоматического партицирование с помощью Redis Cluster.

Вы можете выполнять атомарные операции с этими типами, такие как добавление к строке; увеличение значения в хэше; добавление элемента в список; вычисление пересечения, объединения и разности множеств; или получение элемента с наивысшим рейтингом в отсортированном наборе.

Для достижения максимальной производительности Redis работает с набором данных в памяти. В зависимости от вашего варианта использования Redis может сохранять ваши данные либо путем периодического сброса набора данных на диск, либо путем добавления каждой команды в журнал на диске. Вы также можете отключить сохранение, если вам просто нужен многофункциональный сетевой кэш в памяти.

Redis поддерживает асинхронную репликацию с быстрой неблокирующей синхронизацией и автоматическим переподключением с частичной повторной синхронизацией при разрыве сети.

# Начало работы

## Использование CLI

Внешние программы взаимодействуют с Redis используя TCP-сокет и специальный Redis протокол. Этот протокол реализован в клиентских библиотеках Redis для различных языков программирования. Однако, чтобы упростить взаимодействие с помощью Redis, Redis предоставляет утилиту командной строки, которую можно использовать для отправки команд в Redis. Эта программа называется **redis-cli**.

Первое, что нужно сделать, чтобы проверить, правильно ли работает Redis, - это отправить команду **PING** с помощью redis-cli:
```sh
127.0.0.1:6379> ping
PONG
```

## Безопасность

По умолчанию Redis привязывается ко **всем интерфейсам** и вообще не имеет аутентификации. Если вы используете Redis в очень контролируемой среде, отделенной от внешнего Интернета и вообще от злоумышленников, это нормально. Однако, если незащищенный Redis доступен в Интернете, это вызывает серьезную проблему безопасности. Если вы не уверены на 100%, что ваша среда защищена должным образом, пожалуйста, проверьте следующие шаги, чтобы сделать Red более безопасным, которые перечислены в порядке повышения безопасности.

1. Убедитесь, что порт, который Redis использует для прослушивания подключений (по умолчанию 6379 и дополнительно 16379, если вы запускаете Redis в режиме кластера, плюс 26379 для Sentinel), защищен брандмауэром, чтобы невозможно было связаться с Redis из внешнего мира.
2. Используйте конфигурационный файл, в котором задана директива bind, чтобы гарантировать, что Redis прослушивает только те сетевые интерфейсы, которые вы используете. Например, только интерфейс обратной связи (127.0.0.1), если вы получаете доступ к Redis только локально с того же компьютера, и так далее.
3. Используйте параметр ```requirepass```, чтобы добавить дополнительный уровень безопасности, чтобы клиентам требовалась аутентификация с помощью команды [AUTH](https://redis.io/commands/auth/).
4. Используйте [spiped](http://www.tarsnap.com/spiped.html) или другое программное обеспечение для туннелирования SSL для шифрования трафика между серверами Redis и клиентами Redis, если ваша среда требует шифрования.

## Персистентность

Вы можете узнать, как работает сохранение Redis на [этой](https://redis.io/docs/manual/persistence/) странице, однако для быстрого начала важно понять, если вы запускаете Redis с конфигурацией по умолчанию, Redis будет самопроизвольно сохранять набор данных только время от времени (например, по крайней мере через пять минут, если у вас есть по крайней мере 100 изменений в ваших данных), поэтому, если вы хотите, чтобы ваша база данных сохранялась и загружалась после перезагрузки, обязательно вызывайте команду **SAVE** вручную каждый раз, когда вы хотите принудительно создать снимок набора данных. В противном случае обязательно завершите работу базы данных с помощью команды **SHUTDOWN**:
```sh
redis-cli shutdown
```

Таким образом, Redis обязательно сохранит данные на диске перед завершением работы. 

# Типы данных

## Руководство

### Ключи

Ключи Redis бинарно безопасны, это означает, что вы можете использовать в качестве ключа любую двоичную последовательность, от строки типа "foo" до содержимого JPEG файла. Пустая строка также является допустимым ключом.

Несколько других правил, касающиеся ключей:
* Очень длинные ключи - плохая идея. Например, ключ в 1024 байта - плохая идея не только с точки зрения памяти, но и потому, что поиск ключа в наборе данных может потребовать нескольких дорогостоящих сравнений ключей. Даже когда задача состоит в том, чтобы сопоставить существование большого значения, его хэширование (например, с помощью SHA1) является лучшей идеей, особенно с точки зрения памяти и пропускной способности.
* Очень короткие ключи часто не являются хорошей идеей. Нет особого смысла писать "u1000flw" в качестве ключа, если вместо этого вы можете написать "user: 1000:followers". Последний более удобочитаем, а добавленное пространство незначительно по сравнению с пространством, используемым самим ключом и значением. Хотя короткие ключи, очевидно, потребляют немного меньше памяти, ваша задача - найти правильный баланс.
* Старайтесь придерживаться схемы. Например, "object-type:id" - хорошая идея ("user:1000"). Точки или тире часто используются для полей, состоящих из нескольких слов, как в "comment:4321:reply.to" или "comment:4321:reply-to".
* Максимальный размер ключа 512 MB.

### Строки

Строки Redis - это самый простой тип значения, который вы можете связать с ключом Redis. Это единственный тип данных в Memcached, поэтому для новичков также очень естественно использовать его в Redis.

Поскольку ключи Redis являются строками, когда мы также используем тип string в качестве значения, мы сопоставляем строку с другой строкой. Тип данных string полезен для ряда случаев использования, таких как кэширование HTML фрагментов или страниц.

Пример:
```sh
> set mykey somevalue
OK
> get mykey
"somevalue"
```

Как вы можете видеть, с помощью команд **SET** и **GET** мы устанавливаем и извлекаем строковое значение. Обратите внимание, что **SET** заменит любое существующее значение, уже сохраненное в ключе, в случае, если ключ уже существует, даже если ключ связан с нестроковым значением. 

Значения могут быть строками (включая двоичные данные) любого типа, например, вы можете сохранить изображение в формате jpeg внутри значения. Значение не может быть больше 512 МБ.

Команда **SET** имеет интересные опции, которые предоставляются в качестве дополнительных аргументов. Например, можно указать **SET** вернуть ошибку, если ключ уже существует, или наоборот, чтобы он вернул успешный статус только в том случае, если ключ уже существует:
```sh
> set mykey newval nx
(nil)
> set mykey newval xx
OK
```

Даже если строки являются базовыми значениями Redis, с ними можно выполнять интересные операции. Например, одним из них является атомарное приращение:
```sh
> set counter 100
OK
> get counter
"100"
> incr counter
(integer) 101
> incr counter
(integer) 102
> incrby counter 50
(integer) 152
```

Команда [INCR](https://redis.io/commands/incr/) анализирует строковое значение как целое, увеличивает его на единицу и устанавливает полученное значение в качестве нового значения. Существуют и другие подобные команды, такие как [INCRBY](https://redis.io/commands/incrby), [DECR](https://redis.io/commands/decr) и [DERBY](https://redis.io/commands/decrby). Внутренне это всегда одна и та же команда, действующая немного по-другому.

Что это значит, что INCR атомарный? Несколько клиентов, вызывающих INCR по одному и тому же ключу, никогда не войдут в состояние гонки. Например, никогда не случится так, что клиент 1 прочитает "10", клиент 2 прочитает "10" одновременно, оба увеличат до 11 и установят новое значение на 11. Конечное значение всегда будет равно 12, и операция чтения-увеличения-вставки выполняется в то время, когда все остальные клиенты не выполняют команду(одновременно).

Существует ряд команд для работы со строками. Например, команда **GETSET** устанавливает ключу новое значение, возвращая в результате старое значение. Вы можете использовать эту команду, например, если у вас есть система, которая увеличивает ключ Redis с помощью **INCR** каждый раз, когда ваш сайт получает нового посетителя. Возможно, вы захотите собирать эту информацию один раз в час, не теряя ни единого приращения. Вы можете сделать **SET** ключа, присвоив ему новое значение "0" и считав старое значение обратно.

Возможность устанавливать или извлекать значение нескольких ключей в одной команде также полезна для уменьшения задержки. По этой причине существуют команды **MSET** и **MGET**:
```sh
> mset a 10 b 20 c 30
OK
> mget a b c
1) "10"
2) "20"
3) "30"
> mget a b asd c
1) "10"
2) "20"
3) (nil)
4) "30"
```

Когда используется **MGET**, Redis возвращает массив значений.

### Изменение и запрос пространства ключей

Существуют команды, которые не определены для определенных типов, но полезны для взаимодействия с пространством ключей и, таким образом, могут использоваться с ключами любого типа.

Например, команда EXISTS возвращает 1 или 0, чтобы указать, существует данный ключ в базе данных или нет, в то время как команда DEL удаляет ключ и связанное с ним значение, каким бы оно ни было.
```sh
> set mykey hello
OK
> exists mykey
(integer) 1
> del mykey
(integer) 1
> exists mykey
(integer) 0
```

Из примеров вы также можете видеть, как сам DEL возвращает 1 или 0 в зависимости от того, был ли ключ удален (он существовал) или нет (такого ключа с таким именем не было).

Существует множество команд, связанных с пространством ключей, но две вышеуказанные являются основными вместе с командой **TYPE**, которая возвращает тип значения, сохраненного в указанном ключе:
```sh
> set mykey x
OK
> type mykey
string
> del mykey
(integer) 1
> type mykey
none
```

### Истечение срока действия ключа

Прежде чем двигаться дальше, мы должны рассмотреть важную функцию Redis, которая работает независимо от типа значения, которое вы сохраняете: срок действия ключа. Истечение срока действия ключа позволяет вам установить тайм-аут для ключа, также известный как "время жизни"(time to live) или "TTL". По истечении срока службы ключ автоматически уничтожается.

Несколько важных замечаний об истечении срока действия ключа:

* Сроки действия могут быть установлены как с точностью до секунд, так и с точностью до миллисекунд.
* Однако разрешение по времени истечения всегда равно 1 миллисекунде.
* Информация об истечении срока действия реплицируется и сохраняется на диске, время фактически проходит, когда ваш сервер Redis выключен (это означает, что Redis сохраняет дату истечения срока действия ключа).

Используйте команду EXPIRE, чтобы установить срок действия ключа:
```sh
> set key some-value
OK
> expire key 5
(integer) 1
> get key (immediately)
"some-value"
> get key (a few moments later)
(nil)
```

Ключ исчез между двумя вызовами **GET**, так как второй вызов был задержан более чем на 5 секунд. В приведенном выше примере мы использовали **EXPIRE** для того, чтобы установить тайм-аут (его также можно использовать для того, чтобы установить другой тайм-аут для ключа, у которого он уже есть, например, **PERSIST** можно использовать для того, чтобы удалить тайм-аут и сделать ключ постоянным навсегда). Однако мы также можем создавать ключи с истекающим сроком действия, используя другие команды Redis. Например, используя **SET** с параметрами:
```sh
> set key 100 ex 10
OK
> ttl key
(integer) 7
```

В приведенном выше примере задается ключ со строковым значением 100, срок действия которого составляет десять секунд. Позже вызывается команда TTL, чтобы проверить оставшееся время жизни ключа.

Чтобы установить и проверить срок действия в миллисекундах, проверьте **PEXPIRE** и **PTTL** команды, а также полный список **SET** параметров.

### Списки

С очень общей точки зрения список - это просто последовательность упорядоченных элементов: 10,20,1,2,3 - это список.

Списки Redis реализуются с помощью связанных списков. Это означает, что даже если у вас есть миллионы элементов внутри списка, операция добавления нового элемента в начало или в конец списка выполняется за константное время. Скорость добавления нового элемента с помощью команды **LPUSH** в начало списка с десятью элементами такая же, как при добавлении элемента в начало списка с 10 миллионами элементов.

В чем недостаток? Доступ к элементу по индексу осуществляется очень быстро в списках, реализованных с помощью массива (доступ с индексацией по константному времени), и не так быстро в списках, реализованных с помощью связанных списков (где операция требует объема работы, пропорционального индексу элемента).

Списки Redis реализованы с помощью связанных списков, потому что для системы баз данных крайне важно иметь возможность добавлять элементы в очень длинный список очень быстрым способом. Еще одним сильным преимуществом, как вы сейчас увидите, является то, что списки Redis могут быть составлены константной длины за константное время.

Когда важен быстрый доступ к середине большой коллекции элементов, можно использовать другую структуру данных, называемую отсортированными наборами.

#### Первые шаги со списками Redis

Команда **LPUSH** добавляет новый элемент в список слева (в начале), в то время как команда **RPUSH** добавляет новый элемент в список справа (в конце). Наконец, команда **LRANGE** извлекает диапазоны(от i до j индекса включительно) элементов из списков:
```sh
> rpush mylist A
(integer) 1
> rpush mylist B
(integer) 2
> lpush mylist first
(integer) 3
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
```

Обратите внимание, что [LRANGE](https://redis.io/commands/lrange) принимает два индекса, первый и последний элемент возвращаемого диапазона. Оба индекса могут быть отрицательными, указывая Redis начинать отсчет с конца: таким образом, -1 - это последний элемент, -2 - предпоследний элемент списка и так далее.

**RPUSH** и **LPUSH** являются *вариативными* командами, что означает, что вы можете поместить несколько элементов в список за один вызов:
```sh
> rpush mylist 1 2 3 4 5 "foo bar"
(integer) 9
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
4) "1"
5) "2"
6) "3"
7) "4"
8) "5"
9) "foo bar"
```

Важной операцией, определенной в списках Redis, является возможность сделать *pop* элемента. *Pop* элементf - это операция одновременного получения и удаления элемента из списка. Можно делать *pop* элемента слева и справа, аналогично тому, как вы можете вставлять элементы в обе части списка:
```sh
> rpush mylist a b c
(integer) 3
> rpop mylist
"c"
> rpop mylist
"b"
> rpop mylist
"a"
> rpop mylist
(nil)
```

Мы добавили три элемента и сделали *pop* трех элементов, так что в конце этой последовательности команд список пуст, и больше нет элементов для извлечения. Если мы попытаемся сделать *pop* еще одного элемента, то получим nil/NULL. Redis вернул нулевое значение, сигнализирующее о том, что в списке нет элементов.

#### Распространенные варианты использования списков

Списки полезны для ряда задач, два очень типичных варианта использования следующие:
* Запоминать последние обновления, размещенные пользователями в социальной сети.
* Связь между процессами с использованием шаблона потребитель-производитель, где производитель помещает элементы в список, а потребитель (обычно воркер) потребляет эти элементы и выполняет действия. В Redis есть специальные команды списка, которые делают этот вариант использования более надежным и эффективным.

Например Twitter заносит последние твиты, опубликованные пользователями, в списки Redis.

Чтобы пошагово описать распространенный вариант использования, представьте, что на вашей домашней странице отображаются последние фотографии, опубликованные в социальной сети для обмена фотографиями, и вы хотите ускорить доступ.
* Каждый раз, когда пользователь публикует новую фотографию, мы добавляем ее идентификатор в список с помощью **LPUSH**.
* Когда пользователи заходят на домашнюю страницу, мы используем **LRANGE 0 9**, чтобы получить последние 10 опубликованных элементов.

#### Ограниченные списки

Во многих случаях мы просто хотим использовать списки для хранения последних элементов, какими бы они ни были: обновления социальных сетей, журналы/логи или что-либо еще.

Redis позволяет нам использовать списки как ограниченную коллекцию, запоминая только последние N элементов и отбрасывая все самые старые элементы с помощью команды **LTRIM**.

Команда **LTRIM** похожа на **LRANGE**, но вместо отображения указанного диапазона элементов она устанавливает этот диапазон в качестве нового значения списка. Все элементы, находящиеся за пределами заданного диапазона, удаляются.
```sh
> rpush mylist 1 2 3 4 5
(integer) 5
> ltrim mylist 0 2
OK
> lrange mylist 0 -1
1) "1"
2) "2"
3) "3"
```

Приведенная выше команда **LTRIM** сообщает Redis принимать только элементы списка с индексом от 0 до 2, все остальное будет отброшено. Это позволяет использовать очень простой, но полезный шаблон: выполнение операции *push* + операции обрезки(trim) списка вместе, позволяет добавить новый элемент и отбросить элементы, превышающие ограничение:
```sh
LPUSH mylist <some element>
LTRIM mylist 0 999
```

Приведенная выше комбинация добавляет новый элемент и включает в список только 1000 самых новых элементов. С помощью **LRANGE** вы можете получить доступ к топу элементов без необходимости запоминать очень старые данные.

Примечание: хотя технически **LRANGE** имеет зависимость к времени как O(N), доступ к небольшим диапазонам в начале или в конце списка является операцией константного времени.

# Использование Redis

## Redis CLI

Redis-cli (интерфейс командной строки Redis) - это терминальная программа, используемая для отправки команд на сервер Redis и чтения ответов с него. Он имеет два основных режима: интерактивный режим REPL (Read Eval Print Loop), в котором пользователь вводит команды Redis и получает ответы, и командный режим, в котором выполняется ```redis-cli``` с дополнительными аргументами, а ответ выводится на стандартный вывод.

Есть несколько опций, которые вы можете использовать для запуска программы в специальных режимах. Вы можете смоделировать реплику и распечатать поток репликации, который она получает от основного сервера, проверить задержку сервера Redis и отобразить статистику или запросить ASCII-art спектрограмму задержек и частот, среди многих других вещей.

### Использование командной строки

Чтобы выполнить команду Redis и получить ее ответ в stdout, выполните ```redis-cli``` c аргументами:
```sh
~ ❯ redis-cli INCR  mycounter
(integer) 4
```

Ответ команды - 4. Поскольку ответы Redis типизированы (строки, массивы, целые числа, ноль, ошибки и т.д.), Вы видите тип ответа в круглых скобках. Эта дополнительная информация может быть не нужна, когда выходные данные ```redis-cli``` должны использоваться в качестве входных данных другой команды или перенаправляться в файл.
```redis-cli``` показывает дополнительную информацию только для удобства чтения человеком, когда обнаруживает, что стандартный вывод - это tty или терминал. Для всех остальных выходов он автоматически включит *режим необработанного вывода (raw output mode)*, как в следующем примере:
```sh
~ ❯ redis-cli INCR mycounter > /tmp/output.txt
~ ❯ cat /tmp/output.txt
5
```

Обратите внимание, что (целое число) было опущено из выходных данных, поскольку redis-cli обнаружил, что выходные данные больше не записываются в терминал. Вы можете принудительно вывести необработанный вывод даже на терминале с помощью опции --raw:
```sh
~ ❯ redis-cli --raw INCR mycounter
6
```

Вы можете принудительно выводить удобочитаемый вывод при записи в файл или в канал для других команд, используя ```--no-raw```.

### Хост, порт, пароль и база данных

По умолчанию ```redis-cli``` подключается к серверу по адресу 127.0.0.1 с портом 6379. Вы можете изменить это, используя несколько параметров командной строки. Чтобы указать другое имя хоста или IP-адрес, используйте параметр ```-h```. Чтобы установить другой порт, используйте ```-p```.
```sh
~ ❯ redis-cli -h redis15.localnet.org -p 6390 PING
PONG
```

Если ваш экземпляр защищен паролем, опция -a <password> выполнит аутентификацию, избавив от необходимости явно использовать команду [AUTH](https://redis.io/commands/auth/):
```sh
~ ❯ redis-cli -a myUnguessablePazzzzzword123 PING
PONG
```

В целях безопасности настоятельно рекомендуется автоматически вводить пароль в ```redis-cli``` через переменную среды ```REDISCLI_AUTH```.
Наконец, можно отправить команду, которая работает с номером базы данных, отличным от нулевого номера по умолчанию, используя опцию ```-n <dbnum>```:
```sh
~ ❯ redis-cli FLUSHALL
OK
~ ❯ redis-cli -n 1 INCR a
(integer) 1
~ ❯ redis-cli -n 1 INCR a
(integer) 2
~ ❯ redis-cli -n 2 INCR a
(integer) 1
```

Часть или вся эта информация также может быть предоставлена с помощью опции ```-u <url>``` и шаблона URL ```redis://user:password@host:port/dbnum```:
```sh
~ ❯ redis-cli -u redis://LJenkins:p%40ssw0rd@redis-16379.hosted.com:16379/0 PING
PONG
```

### SSL/TLS

По умолчанию ```redis-cli``` использует простое TCP-соединение для подключения к Redis. Вы можете включить SSL/TLS, используя опцию ```--tls```, а также ```--cacert``` или ```--cacertdir``` для настройки пакета или каталога доверенных корневых сертификатов.

Если целевому серверу требуется проверка подлинности с использованием сертификата на стороне клиента, вы можете указать сертификат и соответствующий закрытый ключ, используя ```--cert``` и ```--key```.

### Получение входных данных от других программ

Существует два способа использования ```redis-cli``` для получения входных данных от других команд через стандартный ввод. Один из них заключается в использовании целевой полезной нагрузки в качестве последнего аргумента из *stdin*. Например, чтобы установить ключ Redis ```net_services``` для содержимого файла ```/etc/services``` из локальной файловой системы, используйте параметр ```-x```:
```sh
~ ❯ redis-cli -x SET net_services < /etc/services
OK
~ ❯ redis-cli GETRANGE net_services 0 50
"#\n# Network services, Internet style\n#\n# Note that "
```

В первой строке вышеупомянутого сеанса ```redis-cli``` был выполнен с параметром ```-x```, и файл был перенаправлен на стандартный ввод CLI в качестве значения, удовлетворяющего командной фразе ```SET net_services```. Это полезно для написания скриптов.

Другой подход заключается в передаче ```redis-cli``` последовательности команд, записанных в текстовом файле:
```sh
~ ❯ cat /tmp/commands.txt
SET item:3374 100
INCR item:3374
APPEND item:3374 xxx
GET item:3374
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 101
(integer) 6
"101xxx"
```

Все команды в ```commands.txt``` выполняются последовательно ```redis-cli```, как если бы они были введены пользователем в интерактивном режиме. Строки могут быть заключены в кавычки внутри файла, если это необходимо, так что можно иметь отдельные аргументы с пробелами, символами перевода строки или другими специальными символами:
```sh
~ ❯ cat /tmp/commands.txt
SET arg_example "This is a single argument"
STRLEN arg_example
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 25
```

### Постоянное выполнение команд

Можно выполнить одну команду заданное количество раз с выбранной пользователем паузой между выполнением. Это полезно в разных контекстах - например, когда мы хотим постоянно отслеживать какой-либо ключевой контент или вывод [INFO](https://redis.io/commands/info/), или когда мы хотим имитировать какое-либо повторяющееся событие записи, например, добавление нового элемента в список каждые 5 секунд.

Эта функция управляется двумя опциями: ```-r <count>``` и ```-i <delay>```. Параметр ```-r``` указывает, сколько раз нужно выполнить команду, а ```-i``` задает задержку между различными вызовами команд в секундах (с возможностью указания таких значений, как 0,1, для представления 100 миллисекунд).

По умолчанию интервал (или задержка) установлен на 0, поэтому команды просто выполняются как можно скорее:
```sh
~ ❯ redis-cli -r 5 INCR counter_value
(integer) 1
(integer) 2
(integer) 3
(integer) 4
(integer) 5
```

Чтобы выполнять одну и ту же команду бесконечно, используйте ```-1``` в качестве значения счетчика. Чтобы отслеживать размер RSS-памяти с течением времени, можно использовать следующую команду:
```sh
~ ❯ redis-cli -r -1 -i 1 INFO | grep rss_human
used_memory_rss_human:2.71M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
... a new line will be printed each second ...
```

### CSV вывод

Функция вывода CSV существует в redis-cli для экспорта данных из Redis во внешнюю программу.
```sh
~ ❯ redis-cli LPUSH mylist a b c d
(integer) 4
~ ❯ redis-cli --csv LRANGE mylist 0 -1
"d","c","b","a"
```

### Обработка соединений и реконектов

Использование команды ```CONNECT``` в интерактивном режиме позволяет подключиться к другому экземпляру, указав имя хоста и порт, к которому мы хотим подключиться:
```sh
127.0.0.1:6379> CONNECT metal 6379
metal:6379> PING
PONG
```

Как вы можете видеть, запрос соответствующим образом изменяется при подключении к другому экземпляру сервера. Если предпринимается попытка подключения к экземпляру, который недоступен, ```redis-cli``` переходит в режим отключения и пытается повторно подключиться с каждой новой командой:
```sh
127.0.0.1:6379> CONNECT 127.0.0.1 9999
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
```

Как правило, после обнаружения отключения ```redis-cli``` всегда пытается повторно подключиться прозрачно; если попытка завершается неудачей, он показывает ошибку и переходит в состояние отключения. Ниже приведен пример отключения и повторного подключения:
```sh
127.0.0.1:6379> INFO SERVER
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected> PING
PONG
127.0.0.1:6379> 
(now we are connected again)
```

При повторном подключении redis-cli автоматически повторно выбирает последний выбранный номер базы данных. Однако все другие состояния соединения теряются, например, в рамках транзакции MULTI/EXEC:
```SH
~ ❯ redis-cli
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> PING
QUEUED

( here the server is manually restarted )

127.0.0.1:6379> EXEC
(error) ERR EXEC without MULTI
```

### Выполнение одной и той же команды N раз

Можно выполнить одну и ту же команду несколько раз в интерактивном режиме, добавив к имени команды число:
```sh
127.0.0.1:6379> 5 INCR mycounter
(integer) 7
(integer) 8
(integer) 9
(integer) 10
(integer) 11
```

### Непрерывный режим статистики

Режим непрерывного состояния, вероятно, является одной из менее известных, но очень полезной функцией ```redis-cli``` для мониторинга экземпляров Redis в режиме реального времени. Чтобы включить этот режим, используется параметр ```--stat```. Выходные данные очень четко описывают поведение CLI в этом режиме:
```sh
~ ❯ redis-cli --stat                                                                                                  11m 41s
------- data ------ --------------------- load -------------------- - child -
keys       mem      clients blocked requests            connections
2          1.03M    1       0       29 (+0)             16
2          1.04M    1       0       30 (+1)             16
2          1.04M    1       0       31 (+1)             16
2          1.04M    1       0       32 (+1)             16
2          1.04M    1       0       33 (+1)             16
2          1.04M    1       0       34 (+1)             16
2          1.04M    1       0       35 (+1)             16
2          1.04M    1       0       36 (+1)             16
2          1.04M    1       0       37 (+1)             16
```

В этом режиме каждую секунду печатается новая строка с полезной информацией и различиями значений запроса между старыми точками данных. Использование памяти, количество клиентских подключений и различные другие статистические данные о подключенной базе данных Redis можно легко понять с помощью этого вспомогательного инструмента ```redis-cli```.
Параметр ```-i <interval>``` в этом случае работает как модификатор для изменения частоты, с которой генерируются новые строки. Значение по умолчанию равно одной секунде.

### Сканирование на наличие больших ключей

В этом специальном режиме ```redis-cli``` работает как анализатор пространства ключей. Он сканирует набор данных на наличие больших ключей, но также предоставляет информацию о типах данных, из которых состоит набор данных. Этот режим включается с помощью опции ```--bigkeys``` и выдает подробный вывод:
```sh
$ redis-cli --bigkeys

# Scanning the entire keyspace to find biggest keys as well as
# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec
# per SCAN command (not usually needed).

[00.00%] Biggest string found so far 'key-419' with 3 bytes
[05.14%] Biggest list   found so far 'mylist' with 100004 items
[35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes
[73.91%] Biggest hash   found so far 'myobject' with 3 fields

-------- summary -------

Sampled 506 keys in the keyspace!
Total key length in bytes is 3452 (avg len 6.82)

Biggest string found 'counter:__rand_int__' has 6 bytes
Biggest   list found 'mylist' has 100004 items
Biggest   hash found 'myobject' has 3 fields

504 strings with 1403 bytes (99.60% of keys, avg size 2.78)
1 lists with 100004 items (00.20% of keys, avg size 100004.00)
0 sets with 0 members (00.00% of keys, avg size 0.00)
1 hashs with 3 fields (00.20% of keys, avg size 3.00)
0 zsets with 0 members (00.00% of keys, avg size 0.00)
```

В первой части выходных данных сообщается о каждом новом ключе, который больше, чем предыдущий больший ключ (того же типа). Раздел "summary" (сводка) содержит общую статистику о данных внутри экземпляра Redis.
Программа использует команду [SCAN](https://redis.io/commands/scan/), поэтому ее можно выполнить на загруженном сервере, не влияя на операции, однако параметр ```-i``` можно использовать для того, чтобы ограничить процесс сканирования заданной долей секунды для каждой команды [SCAN](https://redis.io/commands/scan/).

# Управление Redis

## Администрирование Redis

### Память

* Убедитесь, что swap включен и что размер вашего файла подкачки равен объему памяти в вашей системе. Если в Linux не настроена подкачка, и ваш экземпляр Redis случайно потребляет слишком много памяти, Redis может завершиться сбоем, когда ему не хватает памяти, или OOM-killer ядра Linux может убить процесс Redis. Когда swap включен, вы можете обнаруживать всплески задержки и реагировать на них.
* Установите явное ограничение параметра ```maxmemory``` в вашем экземпляре, чтобы убедиться, что он будет сообщать об ошибках, а не о сбое, когда предел системной памяти близок к достижению. Обратите внимание, что максимальная память должна быть установлена путем вычисления накладных расходов для Radis, отличных от данных, и накладных расходов на фрагментацию. Поэтому, если вы считаете, что у вас есть 10 ГБ свободной памяти, установите для параметра значение 8 или 9.
* Если вы используете Redis в приложении с интенсивной записью, сохраняя файл RDB на диске или перезаписывая журнал AOF, Redis может использовать в 2 раза больше памяти, чем обычно используется. Используемая дополнительная память пропорциональна количеству страниц памяти, измененных записями во время процесса сохранения, поэтому она часто пропорциональна количеству ключей (или элементов агрегированных типов), затронутых за это время. Убедитесь, что размер вашей памяти соответствует этому.
* Обратитесь к командам [LATENCY DOCTOR](https://redis.io/commands/latency-doctor/) и [MEMORY DOCTOR](https://redis.io/commands/memory-doctor/), чтобы устранить неполадки.

### Репликация

* Настройте нетривиальное отставание репликации пропорционально объему используемой Redis памяти. Отставание позволяет репликам гораздо легче синхронизироваться с основным (главным) экземпляром.
* Если вы используете репликацию, Redis выполняет сохранение в базе данных, даже если сохранение отключено. (Это не относится к бездисковой репликации.) Если вы не используете диск на главном компьютере, включите бездисковую репликацию.
* Если вы используете репликацию, убедитесь, что либо на вашем главном сервере включена персистентность (сохраняемость данных), либо он не перезапускается автоматически при сбое. Реплики будут пытаться сохранить точную копию мастера, поэтому, если он перезапускается с пустым набором данных, реплики также будут удалены.

### Обновление или перезапуск экземпляра Redis без простоев

Redis разработан таким образом, чтобы быть длительным процессом на вашем сервере. Вы можете изменить многие параметры конфигурации, используя команду [CONFIG SET](https://redis.io/commands/config-set/). Вы также можете переключиться с AOF на сохранение моментальных снимков RDB или наоборот, не перезапуская Redis. Проверьте выходные данные команды ```CONFIG GET *``` для получения дополнительной информации.

Время от времени требуется перезапуск, например, для обновления процесса Redis до более новой версии или когда вам нужно изменить параметр конфигурации, который в настоящее время не поддерживается командой [CONFIG](https://redis.io/commands/config/).

Выполните следующие действия, чтобы избежать простоев:
* Настройте свой новый экземпляр Redis в качестве реплики для вашего текущего экземпляра Redis. Для этого вам нужен другой сервер или сервер с достаточным объемом оперативной памяти, чтобы поддерживать одновременную работу двух экземпляров Redis.
* Если вы используете один сервер, убедитесь, что реплика запущена на другом порту, отличном от мастера, в противном случае реплика не сможет запуститься.
* Дождитесь завершения начальной синхронизации репликации. Проверьте файл журнала реплики.
* Используя[INFO](https://redis.io/commands/info/), убедитесь, что мастер и реплика имеют одинаковое количество ключей. Используйте *redis-cli*, чтобы проверить, что реплика работает должным образом и отвечает на ваши команды.
* Разрешить запись в реплику, используя конфигурационный ```CONFIG SET slave-read-only no```.
* Настройте всех своих клиентов на использование нового экземпляра (реплики). Обратите внимание, что вы можете использовать команду [CLIENT PAUSE](https://redis.io/commands/client-pause/), чтобы гарантировать, что ни один клиент не сможет выполнить запись на старый мастер во время переключения.
* Как только вы подтвердите, что ведущее устройство больше не получает никаких запросов (вы можете проверить это с помощью команды [MONITOR](https://redis.io/commands/monitor/)), выберите реплику в качестве ведущего устройства с помощью команды ```REPLICAOF NO ONE```, а затем завершите работу ведущего устройства.

Если вы используете Redis Sentinel или Redis Cluster, самый простой способ обновления до более новых версий - обновлять одну реплику за другой. Затем вы можете выполнить переход на другой ресурс вручную, чтобы продвинуть одну из обновленных реплик в master, и, наконец, продвинуть последнюю реплику.
