- [Введение](#введение)
- [Начало работы](#начало-работы)
  - [Использование CLI](#использование-cli)
  - [Безопасность](#безопасность)
  - [Персистентность](#персистентность)
- [Типы данных](#типы-данных)
  - [Руководство](#руководство)
    - [Ключи](#ключи)
    - [Строки](#строки)
    - [Изменение и запрос пространства ключей](#изменение-и-запрос-пространства-ключей)
    - [Истечение срока действия ключа](#истечение-срока-действия-ключа)
    - [Списки](#списки)
      - [Первые шаги со списками Redis](#первые-шаги-со-списками-redis)
      - [Распространенные варианты использования списков](#распространенные-варианты-использования-списков)
      - [Ограниченные списки](#ограниченные-списки)
    - [Блокирующие операции со списками](#блокирующие-операции-со-списками)
    - [Автоматическое создание и удаление ключей](#автоматическое-создание-и-удаление-ключей)
    - [Хэши](#хэши)
    - [Множества/наборы](#множестванаборы)
    - [Сортированные множества](#сортированные-множества)
      - [Работа c диапазонами(range)](#работа-c-диапазонамиrange)
      - [Лексикографический счет](#лексикографический-счет)
    - [Обновление результатов: таблицы лидеров](#обновление-результатов-таблицы-лидеров)
- [Использование Redis](#использование-redis)
  - [Redis CLI](#redis-cli)
    - [Использование командной строки](#использование-командной-строки)
    - [Хост, порт, пароль и база данных](#хост-порт-пароль-и-база-данных)
    - [SSL/TLS](#ssltls)
    - [Получение входных данных от других программ](#получение-входных-данных-от-других-программ)
    - [Постоянное выполнение команд](#постоянное-выполнение-команд)
    - [CSV вывод](#csv-вывод)
    - [Обработка соединений и реконектов](#обработка-соединений-и-реконектов)
    - [Выполнение одной и той же команды N раз](#выполнение-одной-и-той-же-команды-n-раз)
    - [Непрерывный режим статистики](#непрерывный-режим-статистики)
    - [Сканирование на наличие больших ключей](#сканирование-на-наличие-больших-ключей)
- [Управление Redis](#управление-redis)
  - [Администрирование Redis](#администрирование-redis)
    - [Память](#память)
    - [Репликация](#репликация)
    - [Обновление или перезапуск экземпляра Redis без простоев](#обновление-или-перезапуск-экземпляра-redis-без-простоев)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


# Введение

Redis - это хранилище структур данных в памяти с открытым исходным кодом (лицензия BSD), используемое в качестве базы данных, кэша, брокера сообщений и механизма потоковой передачи. Redis предоставляет такие структуры данных как строки, хэши, списки, наборы, растровые изображения, гиперлоги, геопространственные индексы и потоки. Redis имеет встроенную репликацию, сценарии Lua, удаление по LRU, транзакции и различные уровни сохраняемости на диске, а также обеспечивает высокую доступность с помощью Redis Sentinel и автоматического партицирование с помощью Redis Cluster.

Вы можете выполнять атомарные операции с этими типами, такие как добавление к строке; увеличение значения в хэше; добавление элемента в список; вычисление пересечения, объединения и разности множеств; или получение элемента с наивысшим рейтингом в отсортированном наборе.

Для достижения максимальной производительности Redis работает с набором данных в памяти. В зависимости от вашего варианта использования Redis может сохранять ваши данные либо путем периодического сброса набора данных на диск, либо путем добавления каждой команды в журнал на диске. Вы также можете отключить сохранение, если вам просто нужен многофункциональный сетевой кэш в памяти.

Redis поддерживает асинхронную репликацию с быстрой неблокирующей синхронизацией и автоматическим переподключением с частичной повторной синхронизацией при разрыве сети.

# Начало работы

## Использование CLI

Внешние программы взаимодействуют с Redis используя TCP-сокет и специальный Redis протокол. Этот протокол реализован в клиентских библиотеках Redis для различных языков программирования. Однако, чтобы упростить взаимодействие с помощью Redis, Redis предоставляет утилиту командной строки, которую можно использовать для отправки команд в Redis. Эта программа называется **redis-cli**.

Первое, что нужно сделать, чтобы проверить, правильно ли работает Redis, - это отправить команду **PING** с помощью redis-cli:
```sh
127.0.0.1:6379> ping
PONG
```

## Безопасность

По умолчанию Redis привязывается ко **всем интерфейсам** и вообще не имеет аутентификации. Если вы используете Redis в очень контролируемой среде, отделенной от внешнего Интернета и вообще от злоумышленников, это нормально. Однако, если незащищенный Redis доступен в Интернете, это вызывает серьезную проблему безопасности. Если вы не уверены на 100%, что ваша среда защищена должным образом, пожалуйста, проверьте следующие шаги, чтобы сделать Red более безопасным, которые перечислены в порядке повышения безопасности.

1. Убедитесь, что порт, который Redis использует для прослушивания подключений (по умолчанию 6379 и дополнительно 16379, если вы запускаете Redis в режиме кластера, плюс 26379 для Sentinel), защищен брандмауэром, чтобы невозможно было связаться с Redis из внешнего мира.
2. Используйте конфигурационный файл, в котором задана директива bind, чтобы гарантировать, что Redis прослушивает только те сетевые интерфейсы, которые вы используете. Например, только интерфейс обратной связи (127.0.0.1), если вы получаете доступ к Redis только локально с того же компьютера, и так далее.
3. Используйте параметр ```requirepass```, чтобы добавить дополнительный уровень безопасности, чтобы клиентам требовалась аутентификация с помощью команды [AUTH](https://redis.io/commands/auth/).
4. Используйте [spiped](http://www.tarsnap.com/spiped.html) или другое программное обеспечение для туннелирования SSL для шифрования трафика между серверами Redis и клиентами Redis, если ваша среда требует шифрования.

## Персистентность

Вы можете узнать, как работает сохранение Redis на [этой](https://redis.io/docs/manual/persistence/) странице, однако для быстрого начала важно понять, если вы запускаете Redis с конфигурацией по умолчанию, Redis будет самопроизвольно сохранять набор данных только время от времени (например, по крайней мере через пять минут, если у вас есть по крайней мере 100 изменений в ваших данных), поэтому, если вы хотите, чтобы ваша база данных сохранялась и загружалась после перезагрузки, обязательно вызывайте команду **SAVE** вручную каждый раз, когда вы хотите принудительно создать снимок набора данных. В противном случае обязательно завершите работу базы данных с помощью команды **SHUTDOWN**:
```sh
redis-cli shutdown
```

Таким образом, Redis обязательно сохранит данные на диске перед завершением работы. 

# Типы данных

## Руководство

### Ключи

Ключи Redis бинарно безопасны, это означает, что вы можете использовать в качестве ключа любую двоичную последовательность, от строки типа "foo" до содержимого JPEG файла. Пустая строка также является допустимым ключом.

Несколько других правил, касающиеся ключей:
* Очень длинные ключи - плохая идея. Например, ключ в 1024 байта - плохая идея не только с точки зрения памяти, но и потому, что поиск ключа в наборе данных может потребовать нескольких дорогостоящих сравнений ключей. Даже когда задача состоит в том, чтобы сопоставить существование большого значения, его хэширование (например, с помощью SHA1) является лучшей идеей, особенно с точки зрения памяти и пропускной способности.
* Очень короткие ключи часто не являются хорошей идеей. Нет особого смысла писать "u1000flw" в качестве ключа, если вместо этого вы можете написать "user: 1000:followers". Последний более удобочитаем, а добавленное пространство незначительно по сравнению с пространством, используемым самим ключом и значением. Хотя короткие ключи, очевидно, потребляют немного меньше памяти, ваша задача - найти правильный баланс.
* Старайтесь придерживаться схемы. Например, "object-type:id" - хорошая идея ("user:1000"). Точки или тире часто используются для полей, состоящих из нескольких слов, как в "comment:4321:reply.to" или "comment:4321:reply-to".
* Максимальный размер ключа 512 MB.

### Строки

Строки Redis - это самый простой тип значения, который вы можете связать с ключом Redis. Это единственный тип данных в Memcached, поэтому для новичков также очень естественно использовать его в Redis.

Поскольку ключи Redis являются строками, когда мы также используем тип string в качестве значения, мы сопоставляем строку с другой строкой. Тип данных string полезен для ряда случаев использования, таких как кэширование HTML фрагментов или страниц.

Пример:
```sh
> set mykey somevalue
OK
> get mykey
"somevalue"
```

Как вы можете видеть, с помощью команд **SET** и **GET** мы устанавливаем и извлекаем строковое значение. Обратите внимание, что **SET** заменит любое существующее значение, уже сохраненное в ключе, в случае, если ключ уже существует, даже если ключ связан с нестроковым значением. 

Значения могут быть строками (включая двоичные данные) любого типа, например, вы можете сохранить изображение в формате jpeg внутри значения. Значение не может быть больше 512 МБ.

Команда **SET** имеет интересные опции, которые предоставляются в качестве дополнительных аргументов. Например, можно указать **SET** вернуть ошибку, если ключ уже существует, или наоборот, чтобы он вернул успешный статус только в том случае, если ключ уже существует:
```sh
> set mykey newval nx
(nil)
> set mykey newval xx
OK
```

Даже если строки являются базовыми значениями Redis, с ними можно выполнять интересные операции. Например, одним из них является атомарное приращение:
```sh
> set counter 100
OK
> get counter
"100"
> incr counter
(integer) 101
> incr counter
(integer) 102
> incrby counter 50
(integer) 152
```

Команда [INCR](https://redis.io/commands/incr/) анализирует строковое значение как целое, увеличивает его на единицу и устанавливает полученное значение в качестве нового значения. Существуют и другие подобные команды, такие как [INCRBY](https://redis.io/commands/incrby), [DECR](https://redis.io/commands/decr) и [DERBY](https://redis.io/commands/decrby). Внутренне это всегда одна и та же команда, действующая немного по-другому.

Что это значит, что INCR атомарный? Несколько клиентов, вызывающих INCR по одному и тому же ключу, никогда не войдут в состояние гонки. Например, никогда не случится так, что клиент 1 прочитает "10", клиент 2 прочитает "10" одновременно, оба увеличат до 11 и установят новое значение на 11. Конечное значение всегда будет равно 12, и операция чтения-увеличения-вставки выполняется в то время, когда все остальные клиенты не выполняют команду(одновременно).

Существует ряд команд для работы со строками. Например, команда **GETSET** устанавливает ключу новое значение, возвращая в результате старое значение. Вы можете использовать эту команду, например, если у вас есть система, которая увеличивает ключ Redis с помощью **INCR** каждый раз, когда ваш сайт получает нового посетителя. Возможно, вы захотите собирать эту информацию один раз в час, не теряя ни единого приращения. Вы можете сделать **SET** ключа, присвоив ему новое значение "0" и считав старое значение обратно.

Возможность устанавливать или извлекать значение нескольких ключей в одной команде также полезна для уменьшения задержки. По этой причине существуют команды **MSET** и **MGET**:
```sh
> mset a 10 b 20 c 30
OK
> mget a b c
1) "10"
2) "20"
3) "30"
> mget a b asd c
1) "10"
2) "20"
3) (nil)
4) "30"
```

Когда используется **MGET**, Redis возвращает массив значений.

### Изменение и запрос пространства ключей

Существуют команды, которые не определены для определенных типов, но полезны для взаимодействия с пространством ключей и, таким образом, могут использоваться с ключами любого типа.

Например, команда EXISTS возвращает 1 или 0, чтобы указать, существует данный ключ в базе данных или нет, в то время как команда DEL удаляет ключ и связанное с ним значение, каким бы оно ни было.
```sh
> set mykey hello
OK
> exists mykey
(integer) 1
> del mykey
(integer) 1
> exists mykey
(integer) 0
```

Из примеров вы также можете видеть, как сам DEL возвращает 1 или 0 в зависимости от того, был ли ключ удален (он существовал) или нет (такого ключа с таким именем не было).

Существует множество команд, связанных с пространством ключей, но две вышеуказанные являются основными вместе с командой **TYPE**, которая возвращает тип значения, сохраненного в указанном ключе:
```sh
> set mykey x
OK
> type mykey
string
> del mykey
(integer) 1
> type mykey
none
```

### Истечение срока действия ключа

Прежде чем двигаться дальше, мы должны рассмотреть важную функцию Redis, которая работает независимо от типа значения, которое вы сохраняете: срок действия ключа. Истечение срока действия ключа позволяет вам установить тайм-аут для ключа, также известный как "время жизни"(time to live) или "TTL". По истечении срока службы ключ автоматически уничтожается.

Несколько важных замечаний об истечении срока действия ключа:

* Сроки действия могут быть установлены как с точностью до секунд, так и с точностью до миллисекунд.
* Однако разрешение по времени истечения всегда равно 1 миллисекунде.
* Информация об истечении срока действия реплицируется и сохраняется на диске, время фактически проходит, когда ваш сервер Redis выключен (это означает, что Redis сохраняет дату истечения срока действия ключа).

Используйте команду EXPIRE, чтобы установить срок действия ключа:
```sh
> set key some-value
OK
> expire key 5
(integer) 1
> get key (immediately)
"some-value"
> get key (a few moments later)
(nil)
```

Ключ исчез между двумя вызовами **GET**, так как второй вызов был задержан более чем на 5 секунд. В приведенном выше примере мы использовали **EXPIRE** для того, чтобы установить тайм-аут (его также можно использовать для того, чтобы установить другой тайм-аут для ключа, у которого он уже есть, например, **PERSIST** можно использовать для того, чтобы удалить тайм-аут и сделать ключ постоянным навсегда). Однако мы также можем создавать ключи с истекающим сроком действия, используя другие команды Redis. Например, используя **SET** с параметрами:
```sh
> set key 100 ex 10
OK
> ttl key
(integer) 7
```

В приведенном выше примере задается ключ со строковым значением 100, срок действия которого составляет десять секунд. Позже вызывается команда TTL, чтобы проверить оставшееся время жизни ключа.

Чтобы установить и проверить срок действия в миллисекундах, проверьте **PEXPIRE** и **PTTL** команды, а также полный список **SET** параметров.

### Списки

С очень общей точки зрения список - это просто последовательность упорядоченных элементов: 10,20,1,2,3 - это список.

Списки Redis реализуются с помощью связанных списков. Это означает, что даже если у вас есть миллионы элементов внутри списка, операция добавления нового элемента в начало или в конец списка выполняется за константное время. Скорость добавления нового элемента с помощью команды **LPUSH** в начало списка с десятью элементами такая же, как при добавлении элемента в начало списка с 10 миллионами элементов.

В чем недостаток? Доступ к элементу по индексу осуществляется очень быстро в списках, реализованных с помощью массива (доступ с индексацией по константному времени), и не так быстро в списках, реализованных с помощью связанных списков (где операция требует объема работы, пропорционального индексу элемента).

Списки Redis реализованы с помощью связанных списков, потому что для системы баз данных крайне важно иметь возможность добавлять элементы в очень длинный список очень быстрым способом. Еще одним сильным преимуществом, как вы сейчас увидите, является то, что списки Redis могут быть составлены константной длины за константное время.

Когда важен быстрый доступ к середине большой коллекции элементов, можно использовать другую структуру данных, называемую отсортированными наборами.

#### Первые шаги со списками Redis

Команда **LPUSH** добавляет новый элемент в список слева (в начале), в то время как команда **RPUSH** добавляет новый элемент в список справа (в конце). Наконец, команда **LRANGE** извлекает диапазоны(от i до j индекса включительно) элементов из списков:
```sh
> rpush mylist A
(integer) 1
> rpush mylist B
(integer) 2
> lpush mylist first
(integer) 3
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
```

Обратите внимание, что [LRANGE](https://redis.io/commands/lrange) принимает два индекса, первый и последний элемент возвращаемого диапазона. Оба индекса могут быть отрицательными, указывая Redis начинать отсчет с конца: таким образом, -1 - это последний элемент, -2 - предпоследний элемент списка и так далее.

**RPUSH** и **LPUSH** являются *вариативными* командами, что означает, что вы можете поместить несколько элементов в список за один вызов:
```sh
> rpush mylist 1 2 3 4 5 "foo bar"
(integer) 9
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
4) "1"
5) "2"
6) "3"
7) "4"
8) "5"
9) "foo bar"
```

Важной операцией, определенной в списках Redis, является возможность сделать *pop* элемента. *Pop* элементf - это операция одновременного получения и удаления элемента из списка. Можно делать *pop* элемента слева и справа, аналогично тому, как вы можете вставлять элементы в обе части списка:
```sh
> rpush mylist a b c
(integer) 3
> rpop mylist
"c"
> rpop mylist
"b"
> rpop mylist
"a"
> rpop mylist
(nil)
```

Мы добавили три элемента и сделали *pop* трех элементов, так что в конце этой последовательности команд список пуст, и больше нет элементов для извлечения. Если мы попытаемся сделать *pop* еще одного элемента, то получим nil/NULL. Redis вернул нулевое значение, сигнализирующее о том, что в списке нет элементов.

#### Распространенные варианты использования списков

Списки полезны для ряда задач, два очень типичных варианта использования следующие:
* Запоминать последние обновления, размещенные пользователями в социальной сети.
* Связь между процессами с использованием шаблона потребитель-производитель, где производитель помещает элементы в список, а потребитель (обычно воркер) потребляет эти элементы и выполняет действия. В Redis есть специальные команды списка, которые делают этот вариант использования более надежным и эффективным.

Например Twitter заносит последние твиты, опубликованные пользователями, в списки Redis.

Чтобы пошагово описать распространенный вариант использования, представьте, что на вашей домашней странице отображаются последние фотографии, опубликованные в социальной сети для обмена фотографиями, и вы хотите ускорить доступ.
* Каждый раз, когда пользователь публикует новую фотографию, мы добавляем ее идентификатор в список с помощью **LPUSH**.
* Когда пользователи заходят на домашнюю страницу, мы используем **LRANGE 0 9**, чтобы получить последние 10 опубликованных элементов.

#### Ограниченные списки

Во многих случаях мы просто хотим использовать списки для хранения последних элементов, какими бы они ни были: обновления социальных сетей, журналы/логи или что-либо еще.

Redis позволяет нам использовать списки как ограниченную коллекцию, запоминая только последние N элементов и отбрасывая все самые старые элементы с помощью команды **LTRIM**.

Команда **LTRIM** похожа на **LRANGE**, но вместо отображения указанного диапазона элементов она устанавливает этот диапазон в качестве нового значения списка. Все элементы, находящиеся за пределами заданного диапазона, удаляются.
```sh
> rpush mylist 1 2 3 4 5
(integer) 5
> ltrim mylist 0 2
OK
> lrange mylist 0 -1
1) "1"
2) "2"
3) "3"
```

Приведенная выше команда **LTRIM** сообщает Redis принимать только элементы списка с индексом от 0 до 2, все остальное будет отброшено. Это позволяет использовать очень простой, но полезный шаблон: выполнение операции *push* + операции обрезки(trim) списка вместе, позволяет добавить новый элемент и отбросить элементы, превышающие ограничение:
```sh
LPUSH mylist <some element>
LTRIM mylist 0 999
```

Приведенная выше комбинация добавляет новый элемент и включает в список только 1000 самых новых элементов. С помощью **LRANGE** вы можете получить доступ к топу элементов без необходимости запоминать очень старые данные.

Примечание: хотя технически **LRANGE** имеет зависимость к времени как O(N), доступ к небольшим диапазонам в начале или в конце списка является операцией константного времени.

### Блокирующие операции со списками

Списки обладают особенностью, которая делает их подходящими для реализации очередей и в целом в качестве строительного блока для систем межпроцессной связи: блокирующие операции.

Представьте, что вы хотите поместить элементы в список с помощью одного процесса и использовать другой процесс, чтобы выполнить какую-то работу с этими элементами. Это обычная настройка производителя/потребителя(pub/sub), и она может быть реализована следующим простым способом:
* Чтобы поместить элементы в список, производители вызывают **LPUSH**.
* Чтобы извлечь/обработать элементы из списка, потребители вызывают **RPOP**.

Однако возможно, что иногда список пуст и обрабатывать нечего, поэтому **RPOP** просто возвращает NULL. В этом случае потребитель вынужден подождать некоторое время и повторить попытку с помощью **RPOP**. Это называется polling, и в данном контексте это не очень хорошая идея, поскольку у нее есть несколько недостатков:
* Заставляет Redis и клиентов обрабатывать бесполезные команды (все запросы, когда список пуст, не будут выполнять никакой фактической работы, они просто вернут NULL).
* Добавляет задержку к обработке элементов, так как после того, как воркер получает значение NULL, он ожидает некоторое время. Чтобы уменьшить задержку, мы могли бы меньше ждать между вызовами **RPOP**, что привело бы к усилению проблемы №1, т.е. к большему количеству бесполезных вызовов Redis.

Таким образом, Redis реализует команды, называемые **BRPOP** и **BLPOP**, которые являются версиями **RPOP** и **LPOP**, способными блокироваться, если список пуст: они вернутся к вызывающей стороне только при добавлении нового элемента в список или при достижении указанного пользователем тайм-аута.

Это пример вызова **BRPOP**, который мы могли бы использовать в worker:
```sh
> brpop tasks 5
(nil)
(5.07s)
> rpush tasks tasks do_something
(integer) 2
> brpop tasks 5
1) "tasks"
2) "do_something"
```

Это означает: "дождись элементов в списке задач, но вернись, если через 5 секунд ни один элемент не будет доступен".

Обратите внимание, что вы можете использовать 0 в качестве тайм-аута для ожидания элементов вечно, и вы также можете указать несколько списков, а не только один, чтобы ждать в нескольких списках одновременно и получать уведомления, когда первый список получает элемент.

Несколько вещей, которые следует отметить о **BRPOP**:
* Клиенты обслуживаются определенным образом: первый клиент, который заблокирован в ожидании списка, обслуживается первым, когда элемент пушится каким-либо другим клиентом, и так далее.
* Возвращаемое значение отличается от **RPOP**: это массив из двух элементов, поскольку он также включает имя ключа, поскольку **BRPOP** и **BLPOP** способны блокироваться на ожидании элементов из нескольких списков.
* Если тайм-аут достигнут, возвращается значение NULL.

```sh
> rpush list1 tasks1 do_something1
(integer) 2
> rpush list2 tasks2 do_something2
(integer) 2
> brpop list1 list2 5
1) "list1"
2) "do_something1"
> brpop list1 list2 5
1) "list1"
2) "tasks1"
> brpop list1 list2 5
1) "list2"
2) "do_something2"
> brpop list1 list2 5
1) "list2"
2) "tasks2"
> brpop list1 list2 5
(nil)
(5.01s)
```

Есть еще кое-что, что вам следует знать о списках и операциях блокировки. Предлагаем вам подробнее ознакомиться со следующим:
* С помощью **LMOVE** можно создавать более безопасные очереди или чередующиеся очереди.
* Существует также блокирующий вариант команды, называемый **BLMOVE**.

### Автоматическое создание и удаление ключей

До сих пор в наших примерах нам никогда не приходилось создавать пустые списки перед добавлением элементов или удалять пустые списки, когда в них больше нет элементов. Redis несет ответственность за удаление ключей, когда списки остаются пустыми, или за создание пустого списка, если ключ не существует, и мы пытаемся добавить в него элементы, например, с помощью **LPUSH**.

Это не относится конкретно к спискам, это относится ко всем типам данных Redis, состоящим из нескольких элементов - потоков, наборов, отсортированных наборов и хэшей.

В принципе, мы можем обобщить поведение с помощью трех правил:
* Когда мы добавляем элемент в агрегированный тип данных, если целевой ключ не существует, перед добавлением элемента создается пустой агрегированный тип данных.
* Когда мы удаляем элементы из агрегированного типа данных, если значение остается пустым, ключ автоматически уничтожается. Тип данных Stream является единственным исключением из этого правила.
* Вызов команды, доступной только для чтения, такой как **LLEN** (которая возвращает длину списка), или команды записи, удаляющей элементы, с пустым ключом всегда приводит к тому же результату, как если бы ключ содержал пустой агрегированный тип типа, который команда ожидает найти.
  
Примеры применения правила 1:
```sh
> del mylist
(integer) 1
> lpush mylist 1 2 3
(integer) 3
```

Однако мы не можем выполнять операции с неправильным типом, если ключ существует:
```sh
> set foo bar
OK
> lpush foo 1 2 3
(error) WRONGTYPE Operation against a key holding the wrong kind of value
> type foo
string
```

Примеры применения правила 2:
```sh
> lpush mylist 1 2 3
(integer) 3
> exists mylist
(integer) 1
> lpop mylist
"3"
> lpop mylist
"2"
> lpop mylist
"1"
> exists mylist
(integer) 0
```
Ключ больше не существует после того, как все элементы будут извлечены.

Примеры применения правила 3:
```sh
> del mylist
(integer) 0
> llen mylist
(integer) 0
> lpop mylist
(nil)
```

### Хэши

Хэши Redis выглядят именно так, как можно было бы ожидать от "хэша", пары значений полей:
```sh
> hset user:1000 username antirez birthyear 1977 verified 1
(integer) 3
> hget user:1000 username
"antirez"
> hget user:1000 birthyear
"1977"
> hgetall user:1000
1) "username"
2) "antirez"
3) "birthyear"
4) "1977"
5) "verified"
6) "1"
```

Хотя хэши удобны для представления объектов, на самом деле количество полей, которые вы можете поместить в хэш, не имеет практических ограничений (кроме доступной памяти), поэтому вы можете использовать хэши многими различными способами внутри вашего приложения.

Команда **HSET** задает несколько полей хэша, в то время как **HGET** извлекает одно поле. **HMGET** аналогичен **HGET**, но возвращает массив значений:
```sh
> hmget user:1000 username birthyear no-such-field
1) "antirez"
2) "1977"
3) (nil)
```

Существуют команды, которые также способны выполнять операции с отдельными полями, например, **HINCRBY**:
```sh
> hincrby user:1000 birthyear 10
(integer) 1987
> hincrby user:1000 birthyear 10
(integer) 1997
```

Стоит отметить, что небольшие хэши (т.е. несколько элементов с небольшими значениями) особым образом кодируются в памяти, что делает их очень эффективными с точки зрения памяти.

### Множества/наборы

Множества Redis - это неупорядоченные наборы строк. Команда **SADD** добавляет новые элементы в множество. Также возможно выполнить ряд других операций с множествами, таких как проверка того, существует ли данный элемент, выполнение пересечения, объединения или различия между несколькими множествами и так далее.
```sh
> sadd myset 1 2 3
(integer) 3
> smembers myset
1) "1"
2) "2"
3) "3"
```

Здесь я добавил три элемента в свой набор и сказал Redis вернуть все элементы. Redis может возвращать элементы в любом порядке при каждом вызове, поскольку с пользователем нет контракта о порядке элементов.

В Redis есть команды для проверки состава множества. Например, проверка того, существует ли элемент:
```sh
> sismember myset 3
(integer) 1
> sismember myset 30
(integer) 0
```

"3" находится в множестве, в то время как "30" - нет.

Множества хороши для выражения отношений между объектами. Например, мы можем легко использовать множества для реализации тегов.

Простой способ смоделировать эту проблему - иметь множество для каждого объекта, который мы хотим тегнуть. Множество содержит идентификаторы тегов, связанных с объектом.

Одна из иллюстраций - тегирование новостных статей. Если статья с идентификатором 1000 помечена тегами 1, 2, 5 и 77, множество может связать эти идентификаторы тегов с новостным элементом:
```sh
> sadd news:1000:tags 1 2 5 77
(integer) 4
```

Возможно, мы также захотим иметь и обратную зависимость: список всех новостей, помеченных данным тегом:
```sh
> sadd tag:1:news 1000
(integer) 1
> sadd tag:2:news 1000
(integer) 1
> sadd tag:5:news 1000
(integer) 1
> sadd tag:77:news 1000
(integer) 1
```

Получить все теги для данного объекта просто:
```sh
> smembers news:1000:tags
1) "1"
2) "2"
3) "5"
4) "77"
```

Примечание: в примере мы предполагаем, что у вас есть другая структура данных, например хэш Redis, который сопоставляет идентификаторы тегов с именами тегов.

Существуют и другие нетривиальные операции, которые по-прежнему легко реализовать с помощью правильных команд Redis. Например, нам может понадобиться список всех объектов с тегами 1, 2, 10 и 27 вместе взятых. Мы можем сделать это с помощью команды **SINTER**, которая выполняет пересечение между различными наборами. Мы можем использовать:
```sh
> smembers tag:1:news
1) "1000"
> smembers tag:2:news
1) "1000"
> sinter tag:1:news tag:2:news
1) "1000"
> sinter tag:1:news tag:2:news tag:10:news tag:27:news
(empty array)
```

В дополнение к пересечению вы также можете выполнять объединения, различие, извлекать случайный элемент и так далее.

Команда для извлечения элемента называется **SPOP** и удобна для моделирования определенных проблем. Например, чтобы реализовать веб-игру в покер, вы можете захотеть представить свою колоду набором. Представьте, что мы используем односимвольный префикс для (C) треф, (D) бубен, (H) червей, (S) пик:
```sh
> sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
  D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3
  H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6
  S7 S8 S9 S10 SJ SQ SK
(integer) 52
```

Теперь мы хотим предоставить каждому игроку по 5 карт. Команда **SPOP** удаляет случайный элемент, возвращая его клиенту, так что в данном случае это идеальная операция.

Однако, если мы применим его непосредственно к нашей колоде, в следующей игре нам нужно будет снова заполнить колоду карт, что может быть не идеально. Итак, для начала мы можем сделать копию набора, хранящегося в ключе deck, в ключ game:1:deck.

Это достигается с помощью **SUNIONSTORE**, который обычно выполняет объединение между несколькими множествами и помещает результат в другое множество. Однако, поскольку объединение одного набора это он сам, я могу скопировать свою колоду(deck) следующим образом:
```sh
> sunionstore game:1:deck deck
(integer) 52
```

Теперь мы можем предоставить первому игроку пять карт:
```sh
> spop game:1:deck
"CQ"
> spop game:1:deck
"HJ"
> spop game:1:deck
"CJ"
> spop game:1:deck
"C5"
> spop game:1:deck
"S3"
```

Сейчас самое подходящее время ввести команду множества, которая определяет количество элементов внутри множества. В контексте теории множеств это часто называют *мощностью* множества, поэтому команда Redis называется **SCARED**.
```sh
> scard game:1:deck
(integer) 47
```

Когда вам нужно просто получить случайные элементы, не удаляя их из набора, есть команда **SRANDMEMBER**, подходящая для этой задачи. Она также имеет возможность возвращать как повторяющиеся, так и неповторяющиеся элементы.

### Сортированные множества

Отсортированные множества - это тип данных, который похож на смесь множества и хэша. Как и множества, отсортированные множества состоят из уникальных, неповторяющихся строковых элементов, поэтому в некотором смысле cортированное множество также является множеством.

Однако, хотя элементы внутри множества не упорядочены, каждый элемент в отсортированном множестве связан со значением с плавающей запятой, называемым счетом(score) (вот почему тип также похож на хэш, поскольку каждый элемент сопоставляется со значением).

Более того, элементы в отсортированном множестве берутся по порядку (поэтому они не упорядочиваются по запросу, порядок - это особенность структуры данных, используемой для представления отсортированных набомножеств). Они упорядочены в соответствии со следующим правилом:
* Если B и A - два элемента с разным счетом(score), то A > B, если A.score > B.score.
* Если B и A имеют точно такой же счет(score), то A > B, если строка A лексикографически больше строки B. Строки B и A не могут быть равны, поскольку отсортированные множества содержат только уникальные элементы.

Давайте начнем с простого примера, добавив несколько выбранных имен хакеров в качестве элементов сортированного множества с указанием их года рождения в качестве "score".
```sh
> zadd hackers 1940 "Alan Kay"
(integer) 1
> zadd hackers 1957 "Sophie Wilson"
(integer) 1
> zadd hackers 1953 "Richard Stallman"
(integer) 1
> zadd hackers 1949 "Anita Borg"
(integer) 1
> zadd hackers 1965 "Yukihiro Matsumoto"
(integer) 1
> zadd hackers 1914 "Hedy Lamarr"
(integer) 1
> zadd hackers 1916 "Claude Shannon"
(integer) 1
> zadd hackers 1969 "Linus Torvalds"
(integer) 1
> zadd hackers 1912 "Alan Turing"
(integer) 1
```

Как вы можете видеть, **ZADD** похож на **SADD**, но принимает один дополнительный аргумент (помещаемый перед добавляемым элементом), который является счетом(score). **ZADD** также является переменным, поэтому вы можете указать несколько пар счет-значение, даже если это не используется в приведенном выше примере.

С отсортированными наборами просто вернуть список хакеров, отсортированных по году их рождения, потому что на самом деле они уже отсортированы.

Примечание по реализации: Отсортированные наборы реализованы с помощью двухпортовой структуры данных, содержащей как список пропусков, так и хэш-таблицу, поэтому каждый раз, когда мы добавляем элемент, Redis выполняет операцию O(log(N)). Это хорошо, но когда мы запрашиваем отсортированные элементы, Redis вообще не нужно выполнять никакой работы, все уже отсортировано:
todo: почитать про внутреннее устройство
```sh
> zrange hackers 0 -1
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
6) "Richard Stallman"
7) "Sophie Wilson"
8) "Yukihiro Matsumoto"
9) "Linus Torvalds"
```

Примечание: 0 и -1 означают от индекса элемента 0 до последнего элемента (-1 работает здесь так же, как и в случае команды **LRANGE**).

Что, если я захочу упорядочить их в обратном порядке, от младшего к старшему? Используйте [ZREVRANGE](https://redis.io/commands/zrevrange) вместо [RANGE](https://redis.io/commands/zrange):
```sh
> zrevrange hackers 0 -1
1) "Linus Torvalds"
2) "Yukihiro Matsumoto"
3) "Sophie Wilson"
4) "Richard Stallman"
5) "Anita Borg"
6) "Alan Kay"
7) "Claude Shannon"
8) "Hedy Lamarr"
9) "Alan Turing"
```

Можно также возвращать счет(score), используя аргумент **WITHSCORES**:
```sh
zrange hackers 0 -1 withscores
 1) "Alan Turing"
 2) "1912"
 3) "Hedy Lamarr"
 4) "1914"
 5) "Claude Shannon"
 6) "1916"
 7) "Alan Kay"
 8) "1940"
 9) "Anita Borg"
10) "1949"
11) "Richard Stallman"
12) "1953"
13) "Sophie Wilson"
14) "1957"
15) "Yukihiro Matsumoto"
16) "1965"
17) "Linus Torvalds"
18) "1969"
```

#### Работа c диапазонами(range)

Отсортированные наборы являются очень мощными. Они могут работать на диапазонах. Давайте соберем всех людей, родившихся до 1950 года включительно. Для этого мы используем команду **ZRANGEBYSCORE**:
```sh
> zrangebyscore hackers -inf 1950
1) "Alan Turing"
2) "Hedy Lamarr"
3) "Claude Shannon"
4) "Alan Kay"
5) "Anita Borg"
```

Мы попросили Redis вернуть все элементы со счетом от отрицательной бесконечности до 1950 (включены обе крайности).

Также возможно удалить диапазоны элементов. Давайте удалим всех хакеров, родившихся между 1940 и 1960 годами, из отсортированного набора:
```sh
> zremrangebyscore hackers 1940 1960
(integer) 4
```

**ZREMRANGEBYSCORE**, возможно, не самое лучшее название команды, но она может быть очень полезна и возвращает количество удаленных элементов.

Другой чрезвычайно полезной операцией, определенной для отсортированных множеств, является операция get-rank. Можно спросить, какое положение элемента в множестве.
```sh
> zrank hackers "Claude Shannon"
(integer) 2
```

Команда **ZREVRANK** также доступна для получения счета(score) с учетом элементов, отсортированных по убыванию.

#### Лексикографический счет

В последних версиях Redis 2.8 была введена новая функция, которая позволяет получать диапазоны лексикографически, предполагая, что все элементы в отсортированном наборе вставлены с одинаковым счетом (элементы сравниваются с помощью функции C memcmp, поэтому гарантируется отсутствие сортировки, и каждый экземпляр Redis ответит так же).

Основными командами для работы с лексикографическими диапазонами являются **ZRANGEBYLEX**, **ZREVRANGEBYLEX**, **ZREMRANGEBYLEX** и **ZLEXCOUNT**.

Например, давайте снова добавим наш список известных хакеров, но на этот раз используем нулевой счет для всех элементов:
```sh
> zadd hackers 0 "Alan Kay" 0 "Sophie Wilson" 0 "Richard Stallman" 0
  "Anita Borg" 0 "Yukihiro Matsumoto" 0 "Hedy Lamarr" 0 "Claude Shannon"
  0 "Linus Torvalds" 0 "Alan Turing"
```

Из-за правил упорядочивания отсортированных множеств они уже отсортированы лексикографически:
```sh
> zrange hackers 0 -1
1) "Alan Kay"
2) "Alan Turing"
3) "Anita Borg"
4) "Claude Shannon"
5) "Hedy Lamarr"
6) "Linus Torvalds"
7) "Richard Stallman"
8) "Sophie Wilson"
9) "Yukihiro Matsumoto"
```

Используя **ZRANGEBYLEX**, мы можем запросить лексикографические диапазоны:
```sh
> zrangebylex hackers [B [P
1) "Claude Shannon"
2) "Hedy Lamarr"
3) "Linus Torvalds"
```

Диапазоны могут быть включающими или исключающими (в зависимости от первого символа), также строка infinite и minus infinity задаются соответственно строками + и -. Смотрите документацию для получения дополнительной информации.

Эта функция важна, потому что она позволяет нам использовать отсортированные наборы в качестве общего индекса. Например, если вы хотите проиндексировать элементы с помощью 128-битного целого аргумента без знака, все, что вам нужно сделать, это добавить элементы в отсортированный набор с тем же счетом (например, 0), но с 16-байтовым префиксом, состоящим из 128-битного числа в big endian. Поскольку числа в big endian, упорядоченные лексикографически (в порядке необработанных байтов), на самом деле упорядочены и численно, вы можете запросить диапазоны в 128-битном пространстве и получить значение элемента, отбросив префикс.

### Обновление результатов: таблицы лидеров

Последнее замечание об отсортированных множествах, прежде чем перейти к следующей теме. Результаты отсортированных множеств могут быть обновлены в любое время. Простой вызов **ZADD** для элемента, уже включенного в отсортированный набор, обновит его оценку (и позицию) с O(log(N)) временной сложностью. Таким образом, отсортированные множества подходят, когда есть тонны обновлений.

Из-за этой характеристики распространенным вариантом использования являются доски лидеров. Типичным приложением является игра на Facebook, в которой вы объединяете возможность сортировать пользователей по их наивысшему баллу, а также операцию получения рейтинга, чтобы показать топ-N пользователей и рейтинг пользователя в таблице лидеров (например, "вы здесь набрали 4932 балла")..

# Использование Redis

## Redis CLI

Redis-cli (интерфейс командной строки Redis) - это терминальная программа, используемая для отправки команд на сервер Redis и чтения ответов с него. Он имеет два основных режима: интерактивный режим REPL (Read Eval Print Loop), в котором пользователь вводит команды Redis и получает ответы, и командный режим, в котором выполняется ```redis-cli``` с дополнительными аргументами, а ответ выводится на стандартный вывод.

Есть несколько опций, которые вы можете использовать для запуска программы в специальных режимах. Вы можете смоделировать реплику и распечатать поток репликации, который она получает от основного сервера, проверить задержку сервера Redis и отобразить статистику или запросить ASCII-art спектрограмму задержек и частот, среди многих других вещей.

### Использование командной строки

Чтобы выполнить команду Redis и получить ее ответ в stdout, выполните ```redis-cli``` c аргументами:
```sh
~ ❯ redis-cli INCR  mycounter
(integer) 4
```

Ответ команды - 4. Поскольку ответы Redis типизированы (строки, массивы, целые числа, ноль, ошибки и т.д.), Вы видите тип ответа в круглых скобках. Эта дополнительная информация может быть не нужна, когда выходные данные ```redis-cli``` должны использоваться в качестве входных данных другой команды или перенаправляться в файл.
```redis-cli``` показывает дополнительную информацию только для удобства чтения человеком, когда обнаруживает, что стандартный вывод - это tty или терминал. Для всех остальных выходов он автоматически включит *режим необработанного вывода (raw output mode)*, как в следующем примере:
```sh
~ ❯ redis-cli INCR mycounter > /tmp/output.txt
~ ❯ cat /tmp/output.txt
5
```

Обратите внимание, что (целое число) было опущено из выходных данных, поскольку redis-cli обнаружил, что выходные данные больше не записываются в терминал. Вы можете принудительно вывести необработанный вывод даже на терминале с помощью опции --raw:
```sh
~ ❯ redis-cli --raw INCR mycounter
6
```

Вы можете принудительно выводить удобочитаемый вывод при записи в файл или в канал для других команд, используя ```--no-raw```.

### Хост, порт, пароль и база данных

По умолчанию ```redis-cli``` подключается к серверу по адресу 127.0.0.1 с портом 6379. Вы можете изменить это, используя несколько параметров командной строки. Чтобы указать другое имя хоста или IP-адрес, используйте параметр ```-h```. Чтобы установить другой порт, используйте ```-p```.
```sh
~ ❯ redis-cli -h redis15.localnet.org -p 6390 PING
PONG
```

Если ваш экземпляр защищен паролем, опция -a <password> выполнит аутентификацию, избавив от необходимости явно использовать команду [AUTH](https://redis.io/commands/auth/):
```sh
~ ❯ redis-cli -a myUnguessablePazzzzzword123 PING
PONG
```

В целях безопасности настоятельно рекомендуется автоматически вводить пароль в ```redis-cli``` через переменную среды ```REDISCLI_AUTH```.
Наконец, можно отправить команду, которая работает с номером базы данных, отличным от нулевого номера по умолчанию, используя опцию ```-n <dbnum>```:
```sh
~ ❯ redis-cli FLUSHALL
OK
~ ❯ redis-cli -n 1 INCR a
(integer) 1
~ ❯ redis-cli -n 1 INCR a
(integer) 2
~ ❯ redis-cli -n 2 INCR a
(integer) 1
```

Часть или вся эта информация также может быть предоставлена с помощью опции ```-u <url>``` и шаблона URL ```redis://user:password@host:port/dbnum```:
```sh
~ ❯ redis-cli -u redis://LJenkins:p%40ssw0rd@redis-16379.hosted.com:16379/0 PING
PONG
```

### SSL/TLS

По умолчанию ```redis-cli``` использует простое TCP-соединение для подключения к Redis. Вы можете включить SSL/TLS, используя опцию ```--tls```, а также ```--cacert``` или ```--cacertdir``` для настройки пакета или каталога доверенных корневых сертификатов.

Если целевому серверу требуется проверка подлинности с использованием сертификата на стороне клиента, вы можете указать сертификат и соответствующий закрытый ключ, используя ```--cert``` и ```--key```.

### Получение входных данных от других программ

Существует два способа использования ```redis-cli``` для получения входных данных от других команд через стандартный ввод. Один из них заключается в использовании целевой полезной нагрузки в качестве последнего аргумента из *stdin*. Например, чтобы установить ключ Redis ```net_services``` для содержимого файла ```/etc/services``` из локальной файловой системы, используйте параметр ```-x```:
```sh
~ ❯ redis-cli -x SET net_services < /etc/services
OK
~ ❯ redis-cli GETRANGE net_services 0 50
"#\n# Network services, Internet style\n#\n# Note that "
```

В первой строке вышеупомянутого сеанса ```redis-cli``` был выполнен с параметром ```-x```, и файл был перенаправлен на стандартный ввод CLI в качестве значения, удовлетворяющего командной фразе ```SET net_services```. Это полезно для написания скриптов.

Другой подход заключается в передаче ```redis-cli``` последовательности команд, записанных в текстовом файле:
```sh
~ ❯ cat /tmp/commands.txt
SET item:3374 100
INCR item:3374
APPEND item:3374 xxx
GET item:3374
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 101
(integer) 6
"101xxx"
```

Все команды в ```commands.txt``` выполняются последовательно ```redis-cli```, как если бы они были введены пользователем в интерактивном режиме. Строки могут быть заключены в кавычки внутри файла, если это необходимо, так что можно иметь отдельные аргументы с пробелами, символами перевода строки или другими специальными символами:
```sh
~ ❯ cat /tmp/commands.txt
SET arg_example "This is a single argument"
STRLEN arg_example
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 25
```

### Постоянное выполнение команд

Можно выполнить одну команду заданное количество раз с выбранной пользователем паузой между выполнением. Это полезно в разных контекстах - например, когда мы хотим постоянно отслеживать какой-либо ключевой контент или вывод [INFO](https://redis.io/commands/info/), или когда мы хотим имитировать какое-либо повторяющееся событие записи, например, добавление нового элемента в список каждые 5 секунд.

Эта функция управляется двумя опциями: ```-r <count>``` и ```-i <delay>```. Параметр ```-r``` указывает, сколько раз нужно выполнить команду, а ```-i``` задает задержку между различными вызовами команд в секундах (с возможностью указания таких значений, как 0,1, для представления 100 миллисекунд).

По умолчанию интервал (или задержка) установлен на 0, поэтому команды просто выполняются как можно скорее:
```sh
~ ❯ redis-cli -r 5 INCR counter_value
(integer) 1
(integer) 2
(integer) 3
(integer) 4
(integer) 5
```

Чтобы выполнять одну и ту же команду бесконечно, используйте ```-1``` в качестве значения счетчика. Чтобы отслеживать размер RSS-памяти с течением времени, можно использовать следующую команду:
```sh
~ ❯ redis-cli -r -1 -i 1 INFO | grep rss_human
used_memory_rss_human:2.71M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
... a new line will be printed each second ...
```

### CSV вывод

Функция вывода CSV существует в redis-cli для экспорта данных из Redis во внешнюю программу.
```sh
~ ❯ redis-cli LPUSH mylist a b c d
(integer) 4
~ ❯ redis-cli --csv LRANGE mylist 0 -1
"d","c","b","a"
```

### Обработка соединений и реконектов

Использование команды ```CONNECT``` в интерактивном режиме позволяет подключиться к другому экземпляру, указав имя хоста и порт, к которому мы хотим подключиться:
```sh
127.0.0.1:6379> CONNECT metal 6379
metal:6379> PING
PONG
```

Как вы можете видеть, запрос соответствующим образом изменяется при подключении к другому экземпляру сервера. Если предпринимается попытка подключения к экземпляру, который недоступен, ```redis-cli``` переходит в режим отключения и пытается повторно подключиться с каждой новой командой:
```sh
127.0.0.1:6379> CONNECT 127.0.0.1 9999
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
```

Как правило, после обнаружения отключения ```redis-cli``` всегда пытается повторно подключиться прозрачно; если попытка завершается неудачей, он показывает ошибку и переходит в состояние отключения. Ниже приведен пример отключения и повторного подключения:
```sh
127.0.0.1:6379> INFO SERVER
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected> PING
PONG
127.0.0.1:6379> 
(now we are connected again)
```

При повторном подключении redis-cli автоматически повторно выбирает последний выбранный номер базы данных. Однако все другие состояния соединения теряются, например, в рамках транзакции MULTI/EXEC:
```SH
~ ❯ redis-cli
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> PING
QUEUED

( here the server is manually restarted )

127.0.0.1:6379> EXEC
(error) ERR EXEC without MULTI
```

### Выполнение одной и той же команды N раз

Можно выполнить одну и ту же команду несколько раз в интерактивном режиме, добавив к имени команды число:
```sh
127.0.0.1:6379> 5 INCR mycounter
(integer) 7
(integer) 8
(integer) 9
(integer) 10
(integer) 11
```

### Непрерывный режим статистики

Режим непрерывного состояния, вероятно, является одной из менее известных, но очень полезной функцией ```redis-cli``` для мониторинга экземпляров Redis в режиме реального времени. Чтобы включить этот режим, используется параметр ```--stat```. Выходные данные очень четко описывают поведение CLI в этом режиме:
```sh
~ ❯ redis-cli --stat                                                                                                  11m 41s
------- data ------ --------------------- load -------------------- - child -
keys       mem      clients blocked requests            connections
2          1.03M    1       0       29 (+0)             16
2          1.04M    1       0       30 (+1)             16
2          1.04M    1       0       31 (+1)             16
2          1.04M    1       0       32 (+1)             16
2          1.04M    1       0       33 (+1)             16
2          1.04M    1       0       34 (+1)             16
2          1.04M    1       0       35 (+1)             16
2          1.04M    1       0       36 (+1)             16
2          1.04M    1       0       37 (+1)             16
```

В этом режиме каждую секунду печатается новая строка с полезной информацией и различиями значений запроса между старыми точками данных. Использование памяти, количество клиентских подключений и различные другие статистические данные о подключенной базе данных Redis можно легко понять с помощью этого вспомогательного инструмента ```redis-cli```.
Параметр ```-i <interval>``` в этом случае работает как модификатор для изменения частоты, с которой генерируются новые строки. Значение по умолчанию равно одной секунде.

### Сканирование на наличие больших ключей

В этом специальном режиме ```redis-cli``` работает как анализатор пространства ключей. Он сканирует набор данных на наличие больших ключей, но также предоставляет информацию о типах данных, из которых состоит набор данных. Этот режим включается с помощью опции ```--bigkeys``` и выдает подробный вывод:
```sh
$ redis-cli --bigkeys

# Scanning the entire keyspace to find biggest keys as well as
# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec
# per SCAN command (not usually needed).

[00.00%] Biggest string found so far 'key-419' with 3 bytes
[05.14%] Biggest list   found so far 'mylist' with 100004 items
[35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes
[73.91%] Biggest hash   found so far 'myobject' with 3 fields

-------- summary -------

Sampled 506 keys in the keyspace!
Total key length in bytes is 3452 (avg len 6.82)

Biggest string found 'counter:__rand_int__' has 6 bytes
Biggest   list found 'mylist' has 100004 items
Biggest   hash found 'myobject' has 3 fields

504 strings with 1403 bytes (99.60% of keys, avg size 2.78)
1 lists with 100004 items (00.20% of keys, avg size 100004.00)
0 sets with 0 members (00.00% of keys, avg size 0.00)
1 hashs with 3 fields (00.20% of keys, avg size 3.00)
0 zsets with 0 members (00.00% of keys, avg size 0.00)
```

В первой части выходных данных сообщается о каждом новом ключе, который больше, чем предыдущий больший ключ (того же типа). Раздел "summary" (сводка) содержит общую статистику о данных внутри экземпляра Redis.
Программа использует команду [SCAN](https://redis.io/commands/scan/), поэтому ее можно выполнить на загруженном сервере, не влияя на операции, однако параметр ```-i``` можно использовать для того, чтобы ограничить процесс сканирования заданной долей секунды для каждой команды [SCAN](https://redis.io/commands/scan/).

# Управление Redis

## Администрирование Redis

### Память

* Убедитесь, что swap включен и что размер вашего файла подкачки равен объему памяти в вашей системе. Если в Linux не настроена подкачка, и ваш экземпляр Redis случайно потребляет слишком много памяти, Redis может завершиться сбоем, когда ему не хватает памяти, или OOM-killer ядра Linux может убить процесс Redis. Когда swap включен, вы можете обнаруживать всплески задержки и реагировать на них.
* Установите явное ограничение параметра ```maxmemory``` в вашем экземпляре, чтобы убедиться, что он будет сообщать об ошибках, а не о сбое, когда предел системной памяти близок к достижению. Обратите внимание, что максимальная память должна быть установлена путем вычисления накладных расходов для Radis, отличных от данных, и накладных расходов на фрагментацию. Поэтому, если вы считаете, что у вас есть 10 ГБ свободной памяти, установите для параметра значение 8 или 9.
* Если вы используете Redis в приложении с интенсивной записью, сохраняя файл RDB на диске или перезаписывая журнал AOF, Redis может использовать в 2 раза больше памяти, чем обычно используется. Используемая дополнительная память пропорциональна количеству страниц памяти, измененных записями во время процесса сохранения, поэтому она часто пропорциональна количеству ключей (или элементов агрегированных типов), затронутых за это время. Убедитесь, что размер вашей памяти соответствует этому.
* Обратитесь к командам [LATENCY DOCTOR](https://redis.io/commands/latency-doctor/) и [MEMORY DOCTOR](https://redis.io/commands/memory-doctor/), чтобы устранить неполадки.

### Репликация

* Настройте нетривиальное отставание репликации пропорционально объему используемой Redis памяти. Отставание позволяет репликам гораздо легче синхронизироваться с основным (главным) экземпляром.
* Если вы используете репликацию, Redis выполняет сохранение в базе данных, даже если сохранение отключено. (Это не относится к бездисковой репликации.) Если вы не используете диск на главном компьютере, включите бездисковую репликацию.
* Если вы используете репликацию, убедитесь, что либо на вашем главном сервере включена персистентность (сохраняемость данных), либо он не перезапускается автоматически при сбое. Реплики будут пытаться сохранить точную копию мастера, поэтому, если он перезапускается с пустым набором данных, реплики также будут удалены.

### Обновление или перезапуск экземпляра Redis без простоев

Redis разработан таким образом, чтобы быть длительным процессом на вашем сервере. Вы можете изменить многие параметры конфигурации, используя команду [CONFIG SET](https://redis.io/commands/config-set/). Вы также можете переключиться с AOF на сохранение моментальных снимков RDB или наоборот, не перезапуская Redis. Проверьте выходные данные команды ```CONFIG GET *``` для получения дополнительной информации.

Время от времени требуется перезапуск, например, для обновления процесса Redis до более новой версии или когда вам нужно изменить параметр конфигурации, который в настоящее время не поддерживается командой [CONFIG](https://redis.io/commands/config/).

Выполните следующие действия, чтобы избежать простоев:
* Настройте свой новый экземпляр Redis в качестве реплики для вашего текущего экземпляра Redis. Для этого вам нужен другой сервер или сервер с достаточным объемом оперативной памяти, чтобы поддерживать одновременную работу двух экземпляров Redis.
* Если вы используете один сервер, убедитесь, что реплика запущена на другом порту, отличном от мастера, в противном случае реплика не сможет запуститься.
* Дождитесь завершения начальной синхронизации репликации. Проверьте файл журнала реплики.
* Используя[INFO](https://redis.io/commands/info/), убедитесь, что мастер и реплика имеют одинаковое количество ключей. Используйте *redis-cli*, чтобы проверить, что реплика работает должным образом и отвечает на ваши команды.
* Разрешить запись в реплику, используя конфигурационный ```CONFIG SET slave-read-only no```.
* Настройте всех своих клиентов на использование нового экземпляра (реплики). Обратите внимание, что вы можете использовать команду [CLIENT PAUSE](https://redis.io/commands/client-pause/), чтобы гарантировать, что ни один клиент не сможет выполнить запись на старый мастер во время переключения.
* Как только вы подтвердите, что ведущее устройство больше не получает никаких запросов (вы можете проверить это с помощью команды [MONITOR](https://redis.io/commands/monitor/)), выберите реплику в качестве ведущего устройства с помощью команды ```REPLICAOF NO ONE```, а затем завершите работу ведущего устройства.

Если вы используете Redis Sentinel или Redis Cluster, самый простой способ обновления до более новых версий - обновлять одну реплику за другой. Затем вы можете выполнить переход на другой ресурс вручную, чтобы продвинуть одну из обновленных реплик в master, и, наконец, продвинуть последнюю реплику.
