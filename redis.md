# Введение

Redis - это хранилище структур данных в памяти с открытым исходным кодом (лицензия BSD), используемое в качестве базы данных, кэша, брокера сообщений и механизма потоковой передачи. Redis предоставляет такие структуры данных как строки, хэши, списки, наборы, растровые изображения, гиперлоги, геопространственные индексы и потоки. Redis имеет встроенную репликацию, сценарии Lua, удаление по LRU, транзакции и различные уровни сохраняемости на диске, а также обеспечивает высокую доступность с помощью Redis Sentinel и автоматического партицирование с помощью Redis Cluster.

Вы можете выполнять атомарные операции с этими типами, такие как добавление к строке; увеличение значения в хэше; добавление элемента в список; вычисление пересечения, объединения и разности множеств; или получение элемента с наивысшим рейтингом в отсортированном наборе.

Для достижения максимальной производительности Redis работает с набором данных в памяти. В зависимости от вашего варианта использования Redis может сохранять ваши данные либо путем периодического сброса набора данных на диск, либо путем добавления каждой команды в журнал на диске. Вы также можете отключить сохранение, если вам просто нужен многофункциональный сетевой кэш в памяти.

Redis поддерживает асинхронную репликацию с быстрой неблокирующей синхронизацией и автоматическим переподключением с частичной повторной синхронизацией при разрыве сети.

# Начало работы

## Использование CLI

Внешние программы взаимодействуют с Redis используя TCP-сокет и специальный Redis протокол. Этот протокол реализован в клиентских библиотеках Redis для различных языков программирования. Однако, чтобы упростить взаимодействие с помощью Redis, Redis предоставляет утилиту командной строки, которую можно использовать для отправки команд в Redis. Эта программа называется **redis-cli**.

Первое, что нужно сделать, чтобы проверить, правильно ли работает Redis, - это отправить команду **PING** с помощью redis-cli:
```sh
127.0.0.1:6379> ping
PONG
```

## Безопасность

По умолчанию Redis привязывается ко **всем интерфейсам** и вообще не имеет аутентификации. Если вы используете Redis в очень контролируемой среде, отделенной от внешнего Интернета и вообще от злоумышленников, это нормально. Однако, если незащищенный Redis доступен в Интернете, это вызывает серьезную проблему безопасности. Если вы не уверены на 100%, что ваша среда защищена должным образом, пожалуйста, проверьте следующие шаги, чтобы сделать Red более безопасным, которые перечислены в порядке повышения безопасности.

1. Убедитесь, что порт, который Redis использует для прослушивания подключений (по умолчанию 6379 и дополнительно 16379, если вы запускаете Redis в режиме кластера, плюс 26379 для Sentinel), защищен брандмауэром, чтобы невозможно было связаться с Redis из внешнего мира.
2. Используйте конфигурационный файл, в котором задана директива bind, чтобы гарантировать, что Redis прослушивает только те сетевые интерфейсы, которые вы используете. Например, только интерфейс обратной связи (127.0.0.1), если вы получаете доступ к Redis только локально с того же компьютера, и так далее.
3. Используйте параметр ```requirepass```, чтобы добавить дополнительный уровень безопасности, чтобы клиентам требовалась аутентификация с помощью команды [AUTH](https://redis.io/commands/auth/).
4. Используйте [spiped](http://www.tarsnap.com/spiped.html) или другое программное обеспечение для туннелирования SSL для шифрования трафика между серверами Redis и клиентами Redis, если ваша среда требует шифрования.

## Персистентность

Вы можете узнать, как работает сохранение Redis на [этой](https://redis.io/docs/manual/persistence/) странице, однако для быстрого начала важно понять, если вы запускаете Redis с конфигурацией по умолчанию, Redis будет самопроизвольно сохранять набор данных только время от времени (например, по крайней мере через пять минут, если у вас есть по крайней мере 100 изменений в ваших данных), поэтому, если вы хотите, чтобы ваша база данных сохранялась и перезагружалась после перезагрузки, обязательно вызывайте команду **SAVE** вручную каждый раз, когда вы хотите принудительно создать снимок набора данных. В противном случае обязательно завершите работу базы данных с помощью команды **SHUTDOWN**:
```sh
redis-cli shutdown
```

Таким образом, Redis обязательно сохранит данные на диске перед завершением работы. 

# Инструкции

## Администрирование Redis

### Память

* Убедитесь, что swap включен и что размер вашего файла подкачки равен объему памяти в вашей системе. Если в Linux не настроена подкачка, и ваш экземпляр Redis случайно потребляет слишком много памяти, Redis может завершиться сбоем, когда ему не хватает памяти, или OOM-killer ядра Linux может убить процесс Redis. Когда swap включен, вы можете обнаруживать всплески задержки и реагировать на них.
* Установите явное ограничение параметра ```maxmemory``` в вашем экземпляре, чтобы убедиться, что он будет сообщать об ошибках, а не о сбое, когда предел системной памяти близок к достижению. Обратите внимание, что максимальная память должна быть установлена путем вычисления накладных расходов для Radis, отличных от данных, и накладных расходов на фрагментацию. Поэтому, если вы считаете, что у вас есть 10 ГБ свободной памяти, установите для параметра значение 8 или 9.
* Если вы используете Redis в приложении с интенсивной записью, сохраняя файл RDB на диске или перезаписывая журнал AOF, Redis может использовать в 2 раза больше памяти, чем обычно используется. Используемая дополнительная память пропорциональна количеству страниц памяти, измененных записями во время процесса сохранения, поэтому она часто пропорциональна количеству ключей (или элементов агрегированных типов), затронутых за это время. Убедитесь, что размер вашей памяти соответствует этому.
* Обратитесь к командам [LATENCY DOCTOR](https://redis.io/commands/latency-doctor/) и [MEMORY DOCTOR](https://redis.io/commands/memory-doctor/), чтобы устраненить неполадки.

### Репликация

* Настройте нетривиальное отставание репликации пропорционально объему используемой Redis памяти. Отставание позволяет репликам гораздо легче синхронизироваться с основным (главным) экземпляром.
* Если вы используете репликацию, Redis выполняет сохранение в базе данных, даже если сохранение отключено. (Это не относится к бездисковой репликации.) Если вы не используете диск на главном компьютере, включите бездисковую репликацию.
* Если вы используете репликацию, убедитесь, что либо на вашем главном сервере включена персистентность (сохраняемость данных), либо он не перезапускается автоматически при сбое. Реплики будут пытаться сохранить точную копию мастера, поэтому, если он перезапускается с пустым набором данных, реплики также будут удалены.

### Обновление или перезапуск экземпляра Redis без простоев

Redis разработан таким образом, чтобы быть длительным процессом на вашем сервере. Вы можете изменить многие параметры конфигурации, используя команду [CONFIG SET](https://redis.io/commands/config-set/). Вы также можете переключиться с AOF на сохранение моментальных снимков RDB или наоборот, не перезапуская Redis. Проверьте выходные данные команды ```CONFIG GET *``` для получения дополнительной информации.

Время от времени требуется перезапуск, например, для обновления процесса Redis до более новой версии или когда вам нужно изменить параметр конфигурации, который в настоящее время не поддерживается командой [CONFIG](https://redis.io/commands/config/).

Выполните следующие действия, чтобы избежать простоев:
* Настройте свой новый экземпляр Redis в качестве реплики для вашего текущего экземпляра Redis. Для этого вам нужен другой сервер или сервер с достаточным объемом оперативной памяти, чтобы поддерживать одновременную работу двух экземпляров Redis.
* Если вы используете один сервер, убедитесь, что реплика запущена на другом порту, отличном от мастера, в противном случае реплика не сможет запуститься.
* Дождитесь завершения начальной синхронизации репликации. Проверьте файл журнала реплики.
* Используя[INFO](https://redis.io/commands/info/), убедитесь, что мастер и реплика имеют одинаковое количество ключей. Используйте *redis-cli*, чтобы проверить, что реплика работает должным образом и отвечает на ваши команды.
* Разрешить запись в реплику, используя конфигурационный ```CONFIG SET slave-read-only no```.
* Настройте всех своих клиентов на использование нового экземпляра (реплики). Обратите внимание, что вы можете использовать команду [CLIENT PAUSE](https://redis.io/commands/client-pause/), чтобы гарантировать, что ни один клиент не сможет выполнить запись на старый мастер во время переключения.
* Как только вы подтвердите, что ведущее устройство больше не получает никаких запросов (вы можете проверить это с помощью команды [MONITOR](https://redis.io/commands/monitor/)), выберите реплику в качестве ведущего устройства с помощью команды ```REPLICAOF NO ONE```, а затем завершите работу ведущего устройства.

Если вы используете Redis Sentinel или Redis Cluster, самый простой способ обновления до более новых версий - обновлять одну реплику за другой. Затем вы можете выполнить переход на другой ресурс вручную, чтобы продвинуть одну из обновленных реплик в master, и, наконец, продвинуть последнюю реплику.

## Redis CLI

Redis-cli (интерфейс командной строки Redis) - это терминальная программа, используемая для отправки команд на сервер Redis и чтения ответов с него. Он имеет два основных режима: интерактивный режим REPL (Read Eval Print Loop), в котором пользователь вводит команды Redis и получает ответы, и командный режим, в котором выполняется ```redis-cli``` с дополнительными аргументами, а ответ выводится на стандартный вывод.

Есть несколько опций, которые вы можете использовать для запуска программы в специальных режимах. Вы можете смоделировать реплику и распечатать поток репликации, который она получает от основного сервера, проверить задержку сервера Redis и отобразить статистику или запросить ASCII-art спектрограмму задержек и частот, среди многих других вещей.

### Использование командной строки

Чтобы выполнить команду Redis и получить ее ответ в stdout, выполните ```redis-cli``` c аргументами:
```sh
~ ❯ redis-cli INCR  mycounter
(integer) 4
```

Ответ команды - 4. Поскольку ответы Redis типизированы (строки, массивы, целые числа, ноль, ошибки и т.д.), Вы видите тип ответа в круглых скобках. Эта дополнительная информация может быть не нужна, когда выходные данные ```redis-cli``` должны использоваться в качестве входных данных другой команды или перенаправляться в файл.
```redis-cli``` показывает дополнительную информацию только для удобства чтения человеком, когда обнаруживает, что стандартный вывод - это tty или терминал. Для всех остальных выходов он автоматически включит *режим необработанного вывода (raw output mode)*, как в следующем примере:
```sh
~ ❯ redis-cli INCR mycounter > /tmp/output.txt
~ ❯ cat /tmp/output.txt
5
```

Обратите внимание, что (целое число) было опущено из выходных данных, поскольку redis-cli обнаружил, что выходные данные больше не записываются в терминал. Вы можете принудительно вывести необработанный вывод даже на терминале с помощью опции --raw:
```sh
~ ❯ redis-cli --raw INCR mycounter
6
```

Вы можете принудительно выводить удобочитаемый вывод при записи в файл или в канал для других команд, используя ```--no-raw```.

### Хост, порт, пароль и база данных

По умолчанию ```redis-cli``` подключается к серверу по адресу 127.0.0.1 с портом 6379. Вы можете изменить это, используя несколько параметров командной строки. Чтобы указать другое имя хоста или IP-адрес, используйте параметр ```-h```. Чтобы установить другой порт, используйте ```-p```.
```sh
~ ❯ redis-cli -h redis15.localnet.org -p 6390 PING
PONG
```

Если ваш экземпляр защищен паролем, опция -a <password> выполнит аутентификацию, избавив от необходимости явно использовать команду [AUTH](https://redis.io/commands/auth/):
```sh
~ ❯ redis-cli -a myUnguessablePazzzzzword123 PING
PONG
```

В целях безопасности настоятельно рекомендуется автоматически вводить пароль в ```redis-cli``` через переменную среды ```REDISCLI_AUTH```.
Наконец, можно отправить команду, которая работает с номером базы данных, отличным от нулевого номера по умолчанию, используя опцию ```-n <dbnum>```:
```sh
~ ❯ redis-cli FLUSHALL
OK
~ ❯ redis-cli -n 1 INCR a
(integer) 1
~ ❯ redis-cli -n 1 INCR a
(integer) 2
~ ❯ redis-cli -n 2 INCR a
(integer) 1
```

Часть или вся эта информация также может быть предоставлена с помощью опции ```-u <url>``` и шаблона URL ```redis://user:password@host:port/dbnum```:
```sh
~ ❯ redis-cli -u redis://LJenkins:p%40ssw0rd@redis-16379.hosted.com:16379/0 PING
PONG
```

### SSL/TLS

По умолчанию ```redis-cli``` использует простое TCP-соединение для подключения к Redis. Вы можете включить SSL/TLS, используя опцию ```--tls```, а также ```--cacert``` или ```--cacertdir``` для настройки пакета или каталога доверенных корневых сертификатов.

Если целевому серверу требуется проверка подлинности с использованием сертификата на стороне клиента, вы можете указать сертификат и соответствующий закрытый ключ, используя ```--cert``` и ```--key```.

### Получение входных данных от других программ

Существует два способа использования ```redis-cli``` для получения входных данных от других команд через стандартный ввод. Один из них заключается в использовании целевой полезной нагрузки в качестве последнего аргумента из *stdin*. Например, чтобы установить ключ Redis ```net_services``` для содержимого файла ```/etc/services``` из локальной файловой системы, используйте параметр ```-x```:
```sh
~ ❯ redis-cli -x SET net_services < /etc/services
OK
~ ❯ redis-cli GETRANGE net_services 0 50
"#\n# Network services, Internet style\n#\n# Note that "
```

В первой строке вышеупомянутого сеанса ```redis-cli``` был выполнен с параметром ```-x```, и файл был перенаправлен на стандартный ввод CLI в качестве значения, удовлетворяющего командной фразе ```SET net_services```. Это полезно для написания скриптов.

Другой подход заключается в передаче ```redis-cli``` последовательности команд, записанных в текстовом файле:
```sh
~ ❯ cat /tmp/commands.txt
SET item:3374 100
INCR item:3374
APPEND item:3374 xxx
GET item:3374
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 101
(integer) 6
"101xxx"
```

Все команды в ```commands.txt``` выполняются последовательно ```redis-cli```, как если бы они были введены пользователем в интерактивном режиме. Строки могут быть заключены в кавычки внутри файла, если это необходимо, так что можно иметь отдельные аргументы с пробелами, символами перевода строки или другими специальными символами:
```sh
~ ❯ cat /tmp/commands.txt
SET arg_example "This is a single argument"
STRLEN arg_example
~ ❯ cat /tmp/commands.txt | redis-cli
OK
(integer) 25
```

### Постоянное выполнение команд

Можно выполнить одну команду заданное количество раз с выбранной пользователем паузой между выполнением. Это полезно в разных контекстах - например, когда мы хотим постоянно отслеживать какой-либо ключевой контент или вывод [INFO](https://redis.io/commands/info/), или когда мы хотим имитировать какое-либо повторяющееся событие записи, например, добавление нового элемента в список каждые 5 секунд.

Эта функция управляется двумя опциями: ```-r <count>``` и ```-i <delay>```. Параметр ```-r``` указывает, сколько раз нужно выполнить команду, а ```-i``` задает задержку между различными вызовами команд в секундах (с возможностью указания таких значений, как 0,1, для представления 100 миллисекунд).

По умолчанию интервал (или задержка) установлен на 0, поэтому команды просто выполняются как можно скорее:
```sh
~ ❯ redis-cli -r 5 INCR counter_value
(integer) 1
(integer) 2
(integer) 3
(integer) 4
(integer) 5
```

Чтобы выполнять одну и ту же команду бесконечно, используйте ```-1``` в качестве значения счетчика. Чтобы отслеживать размер RSS-памяти с течением времени, можно использовать следующую команду:
```sh
~ ❯ redis-cli -r -1 -i 1 INFO | grep rss_human
used_memory_rss_human:2.71M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
used_memory_rss_human:2.73M
... a new line will be printed each second ...
```

### CSV вывод

Функция вывода CSV существует в redis-cli для экспорта данных из Redis во внешнюю программу.
```sh
~ ❯ redis-cli LPUSH mylist a b c d
(integer) 4
~ ❯ redis-cli --csv LRANGE mylist 0 -1
"d","c","b","a"
```

### Обработка соединений и реконектов

Использование команды ```CONNECT``` в интерактивном режиме позволяет подключиться к другому экземпляру, указав имя хоста и порт, к которому мы хотим подключиться:
```sh
127.0.0.1:6379> CONNECT metal 6379
metal:6379> PING
PONG
```

Как вы можете видеть, запрос соответствующим образом изменяется при подключении к другому экземпляру сервера. Если предпринимается попытка подключения к экземпляру, который недоступен, ```redis-cli``` переходит в режим отключения и пытается повторно подключиться с каждой новой командой:
```sh
127.0.0.1:6379> CONNECT 127.0.0.1 9999
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
not connected> PING
Could not connect to Redis at 127.0.0.1:9999: Connection refused
```

Как правило, после обнаружения отключения ```redis-cli``` всегда пытается повторно подключиться прозрачно; если попытка завершается неудачей, он показывает ошибку и переходит в состояние отключения. Ниже приведен пример отключения и повторного подключения:
```sh
127.0.0.1:6379> INFO SERVER
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected> PING
PONG
127.0.0.1:6379> 
(now we are connected again)
```

При повторном подключении redis-cli автоматически повторно выбирает последний выбранный номер базы данных. Однако все другие состояния соединения теряются, например, в рамках транзакции MULTI/EXEC:
```SH
~ ❯ redis-cli
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> PING
QUEUED

( here the server is manually restarted )

127.0.0.1:6379> EXEC
(error) ERR EXEC without MULTI
```

### Выполнение одной и той же команды N раз

Можно выполнить одну и ту же команду несколько раз в интерактивном режиме, добавив к имени команды число:
```sh
127.0.0.1:6379> 5 INCR mycounter
(integer) 7
(integer) 8
(integer) 9
(integer) 10
(integer) 11
```

### Непрерывный режим статистики

Режим непрерывного состояния, вероятно, является одной из менее известных, но очень полезных функций ```redis-cli``` для мониторинга экземпляров Redis в режиме реального времени. Чтобы включить этот режим, используется параметр ```--stat```. Выходные данные очень четко описывают поведение CLI в этом режиме:
```sh
~ ❯ redis-cli --stat                                                                                                  11m 41s
------- data ------ --------------------- load -------------------- - child -
keys       mem      clients blocked requests            connections
2          1.03M    1       0       29 (+0)             16
2          1.04M    1       0       30 (+1)             16
2          1.04M    1       0       31 (+1)             16
2          1.04M    1       0       32 (+1)             16
2          1.04M    1       0       33 (+1)             16
2          1.04M    1       0       34 (+1)             16
2          1.04M    1       0       35 (+1)             16
2          1.04M    1       0       36 (+1)             16
2          1.04M    1       0       37 (+1)             16
```

В этом режиме каждую секунду печатается новая строка с полезной информацией и различиями значений запроса между старыми точками данных. Использование памяти, количество клиентских подключений и различные другие статистические данные о подключенной базе данных Redis можно легко понять с помощью этого вспомогательного инструмента ```redis-cli```.
Параметр ```-i <interval>``` в этом случае работает как модификатор для изменения частоты, с которой генерируются новые строки. Значение по умолчанию равно одной секунде.

### Сканирование на наличие больших ключей

В этом специальном режиме ```redis-cli``` работает как анализатор пространства ключей. Он сканирует набор данных на наличие больших ключей, но также предоставляет информацию о типах данных, из которых состоит набор данных. Этот режим включается с помощью опции ```--bigkeys``` и выдает подробный вывод:
```sh
$ redis-cli --bigkeys

# Scanning the entire keyspace to find biggest keys as well as
# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec
# per SCAN command (not usually needed).

[00.00%] Biggest string found so far 'key-419' with 3 bytes
[05.14%] Biggest list   found so far 'mylist' with 100004 items
[35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes
[73.91%] Biggest hash   found so far 'myobject' with 3 fields

-------- summary -------

Sampled 506 keys in the keyspace!
Total key length in bytes is 3452 (avg len 6.82)

Biggest string found 'counter:__rand_int__' has 6 bytes
Biggest   list found 'mylist' has 100004 items
Biggest   hash found 'myobject' has 3 fields

504 strings with 1403 bytes (99.60% of keys, avg size 2.78)
1 lists with 100004 items (00.20% of keys, avg size 100004.00)
0 sets with 0 members (00.00% of keys, avg size 0.00)
1 hashs with 3 fields (00.20% of keys, avg size 3.00)
0 zsets with 0 members (00.00% of keys, avg size 0.00)
```

В первой части выходных данных сообщается о каждом новом ключе, который больше, чем предыдущий больший ключ (того же типа). Раздел "summary" (сводка) содержит общую статистику о данных внутри экземпляра Redis.
Программа использует команду [SCAN](https://redis.io/commands/scan/), поэтому ее можно выполнить на загруженном сервере, не влияя на операции, однако параметр ```-i``` можно использовать для того, чтобы ограничить процесс сканирования заданной долей секунды для каждой команды [SCAN](https://redis.io/commands/scan/).